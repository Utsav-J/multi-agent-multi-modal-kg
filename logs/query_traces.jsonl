{"run_id": "73bc8f7e-a92a-4e10-826c-8b6e46d5a3fa", "timestamp_utc": "2025-12-21T09:04:27.657543+00:00", "user_question": "how is anaphora resolution done using attention mechanism?", "rewritten_or_decomposed_queries": ["anaphora resolution attention mechanism", "attention-based anaphora resolution models", "using attention for coreference resolution", "anaphora resolution with neural attention"], "retrieved_chunks": [{"chunk_id": "attention_is_all_you_need_raw_chunks_2k_2", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl", "metadata": {"source": "attention_is_all_you_need_raw.md", "chunk_id": "attention_is_all_you_need_raw_chunks_2k_2", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl"}, "text": "[38, 2, 9].\n\n\n    - The encoder contains self-attention layers. In a self-attention layer all of the keys, values\nand queries come from the same place, in this case, the output of the previous layer in the\nencoder. Each position in the encoder can attend to all positions in the previous layer of the\nencoder.\n\n\n    - Similarly, self-attention layers in the decoder allow each position in the decoder to attend to\nall positions in the decoder up to and including that position. We need to prevent leftward\ninformation flow in the decoder to preserve the auto-regressive property. We implement this\ninside of scaled dot-product attention by masking out (setting to _−∞_ ) all values in the input\nof the softmax which correspond to illegal connections. See Figure 2.\n\n\n**3.3** **Position-wise Feed-Forward Networks**\n\n\nIn addition to attention sub-layers, each of the layers in our encoder and decoder contains a fully\nconnected feed-forward network, which is applied to each position separately and identically. This\nconsists of two linear transformations with a ReLU activation in between.\n\n\nFFN( _x_ ) = max(0 _, xW_ 1 + _b_ 1) _W_ 2 + _b_ 2 (2)\n\n\nWhile the linear transformations are the same across different positions, they use different parameters\nfrom layer to layer. Another way of describing this is as two convolutions with kernel size 1.\nThe dimensionality of input and output is _d_ model = 512, and the inner-layer has dimensionality\n_dff_ = 2048.\n\n\n**3.4** **Embeddings and Softmax**\n\n\nSimilarly to other sequence transduction models, we use learned embeddings to convert the input\ntokens and output tokens to vectors of dimension _d_ model. We also use the usual learned linear transformation and softmax function to convert the decoder output to predicted next-token probabilities. In\nour model, we share the same weight matrix between the two embedding layers and the pre-softmax\nlinear transformation, similar to [30]. In the embedding layers, we multiply those weights by _[√]_ _d_ model.\n\n\n5\n\n\nTable 1: Maximum path lengths, per-layer complexity and minimum number of sequential operations\nfor different layer types. _n_ is the sequence length, _d_ is the representation dimension, _k_ is the kernel\nsize of convolutions and _r_ the size of the neighborhood in restricted self-attention.\n\n\nLayer Type Complexity per Layer Sequential Maximum Path Length\nOperations\nSelf-Attention _O_ ( _n_ [2] _· d_ ) _O_ (1) _O_ (1)\nRecurrent _O_ ( _n · d_ [2] ) _O_ ( _n_ ) _O_ ( _n_ )\nConvolutional _O_ ( _k · n · d_ [2] ) _O_ (1) _O_ ( _logk_ ( _n_ ))\nSelf-Attention (restricted) _O_ ( _r · n · d_ ) _O_ (1) _O_ ( _n/r_ )\n\n\n**3.5** **Positional Encoding**\n\n\nSince our model contains no recurrence and no convolution, in order for the model to make use of the\norder of the sequence, we must inject some information about the relative or absolute position of the\ntokens in the sequence. To this end, we add \"positional encodings\" to the input embeddings at the\nbottoms of the encoder and decoder stacks. The positional encodings have the same dimension _d_ model\nas the embeddings, so that the two can be summed. There are many choices of positional encodings,\nlearned and fixed [9].\n\n\nIn this work, we use sine and cosine functions of different frequencies:\n\n\n_PE_ ( _pos,_ 2 _i_ ) = _sin_ ( _pos/_ 10000 [2] _[i/d]_ [model] )\n\n_PE_ ( _pos,_ 2 _i_ +1) = _cos_ ( _pos/_ 10000 [2] _[i/d]_ [model] )\n\n\nwhere _pos_ is the position and _i_ is the dimension. That is, each dimension of the positional encoding\ncorresponds to a sinusoid. The wavelengths form a geometric progression from 2 _π_ to 10000 _·_ 2 _π_ . We\nchose this function because we hypothesized it would allow the model to easily learn to attend by\nrelative positions, since for any fixed offset _k_, _PEpos_ + _k_ can be represented as a linear function of\n_PEpos_ .\n\n\nWe also experimented with using learned positional embeddings [9] instead, and found that the two\nversions produced nearly identical results (see Table 3 row (E)). We chose the sinusoidal version\nbecause it may allow the model to extrapolate to sequence lengths longer than the ones encountered\nduring training.\n\n\n**4** **Why Self-Attention**\n\n\nIn this section we compare various aspects of self-attention layers to the recurrent and convolutional layers commonly used for mapping one variable-length sequence of symbol representations\n( _x_ 1 _, ..., xn_ ) to another sequence of equal length ( _z_ 1 _, ..., zn_ ), with _xi, zi ∈_ R _[d]_, such as a hidden\nlayer in a typical sequence transduction encoder or decoder. Motivating our use of self-attention we\nconsider three desiderata.\n\n\nOne is the total computational complexity per layer. Another is the amount of computation that can\nbe parallelized, as measured by the minimum number of sequential operations required.\n\n\nThe third is the path length between long-range dependencies in the network. Learning long-range\ndependencies is a key challenge in many sequence transduction tasks. One key factor affecting the\nability to learn such dependencies is the length of the paths forward and backward signals have to\ntraverse in the network. The shorter these paths between any combination of positions in the input\nand output sequences, the easier it is to learn long-range dependencies [12]. Hence we also compare\nthe maximum path length between any two input and output positions in networks composed of the\ndifferent layer types.\n\n\nAs noted in Table 1, a self-attention layer connects all positions with a constant number of sequentially\nexecuted operations, whereas a recurrent layer requires _O_ ( _n_ ) sequential operations. In terms of\ncomputational complexity, self-attention layers are faster than recurrent layers when the sequence\n\n\n6\n\n\nlength _n_ is smaller than the representation dimensionality _d_, which is most often the case with\nsentence representations used by state-of-the-art models in machine translations, such as word-piece\n\n[38] and byte-pair [31] representations. To improve computational performance for tasks involving\nvery long sequences, self-attention could be restricted to considering only a neighborhood of size _r_ in\nthe input sequence centered around the respective output position. This would increase the maximum\npath length to _O_ ( _n/r_ ). We plan to investigate this approach further in future work.\n\n\nA single convolutional layer with kernel width _k < n_ does not connect all pairs of input and output\npositions. Doing so requires a stack of _O_ ( _n/k_ ) convolutional layers in the case of contiguous kernels,\nor _O_ ( _logk_ ( _n_ )) in the case of dilated convolutions [18], increasing the length of the longest paths\nbetween any two positions in the network. Convolutional layers are generally more expensive than\nrecurrent layers, by a factor of _k_ . Separable convolutions [6], however, decrease the complexity\nconsiderably, to _O_ ( _k · n · d_ + _n · d_ [2] ). Even with _k_ = _n_, however, the complexity of a separable\nconvolution is equal to the combination of a self-attention layer and a point-wise feed-forward layer,\nthe approach we take in our model.\n\n\nAs side benefit, self-attention could yield more interpretable models. We inspect attention distributions\nfrom our models and present and discuss examples in the appendix. Not only do individual attention\nheads clearly learn to perform different tasks, many appear to exhibit behavior related to the syntactic\nand semantic structure of the sentences.\n\n\n**5** **Training**\n\n\nThis section describes the training regime for our models.\n\n\n**5.1** **Training Data and Batching**"}, {"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_0", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl", "metadata": {"source": "neuronal_attention_circuits_raw.md", "chunk_id": "neuronal_attention_circuits_raw_chunks_2k_0", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}, "text": "## **Neuronal Attention Circuit (NAC) for Representation Learning**\n\n**Waleed Razzaq** [1] **Izis Kankaraway** [1] **Yun-Bo Zhao** [1 2]\n\n\n\n**Abstract**\n\nAttention improves representation learning over\nRNNs, but its discrete nature limits continuoustime (CT) modeling. We introduce Neuronal Attention Circuit (NAC), a novel, biologically plausible CT-Attention mechanism that reformulates\n\nattention logits computation as the solution to a\nlinear first-order ODE with nonlinear interlinked\ngates derived from repurposing _C. elegans_ Neuronal Circuit Policies (NCPs) wiring mechanism.\nNAC replaces dense projections with sparse sensory gates for key-query projections and a sparse\nbackbone network with two heads for computing\n_content-target_ and _learnable time-constant_ gates,\nenabling efficient adaptive dynamics. NAC supports three attention logit computation modes: (i)\nexplicit Euler integration, (ii) exact closed-form\nsolution, and (iii) steady-state approximation. To\nimprove memory intensity, we implemented a\nsparse Top- _K_ pairwise concatenation scheme that\nselectively curates key-query interactions. We\nprovide rigorous theoretical guarantees, including\nstate stability, bounded approximation errors, and\nuniversal approximation. Empirically, we implemented NAC in diverse domains, including irregular time-series classification, lane-keeping for\nautonomous vehicles, and industrial prognostics.\nWe observed that NAC matches or outperforms\ncompeting baselines in accuracy and occupies an\nintermediate position in runtime and memory efficiency compared with several CT baselines.\n\n\n**1. Introduction**\n\n\nLearning representations of sequential data in temporal or\nspatio-temporal domains is essential for capturing patterns\nand enabling accurate forecasting. Discrete-time Recurrent neural networks (DT-RNNs) such as RNN (Rumelhart et al., 1985; Jordan, 1997), Long-short term memory\n\n\n1Department of Automation, University of Science & Technology of China, Hefei, China [2] Institute of Artificial Intelligence,\nHefei Comprehensive National Science Center. Correspondence to:\nYun-Bo Zhao _<_ ybzhao@ustc.edu.cn _>_, Waleed Razzaq _<_ waleedrazzaq@mail.ustc.edu.cn _>_ .\n\n\n_Preprint. December 12, 2025._\n\n\n\n(LSTM) (Hochreiter & Schmidhuber, 1997), and Gated Recurrent Unit (GRU) (Cho et al., 2014) model sequential dependencies by iteratively updating hidden states to represent\nor predict future elements in a sequence. While effective\nfor regularly sampled sequences, DT-RNNs face challenges\nwith irregularly sampled data because they assume uniform\ntime intervals. In addition, vanishing gradients can make\nit difficult to capture long-term dependencies (Hochreiter,\n1998).\nContinuous-time RNNs (CT-RNNs) (Rubanova et al., 2019)\nmodel hidden states as ordinary differential equations\n(ODEs), allowing them to process inputs that arrive at arbitrary or irregular time intervals. Mixed-memory RNNs\n(mmRNNs) (Lechner & Hasani, 2022) build on this idea\nby separating memory compartments from time-continuous\nstates, helping maintain stable error propagation while capturing continuous-time dynamics. Liquid neural networks\n(LNNs) (Hasani et al., 2021; 2022) take a biologically inspired approach by assigning variable time-constants to hidden states, improving adaptability and robustness, though\nvanishing gradients can still pose challenges during training.\nThe attention mechanisms (Vaswani et al., 2017) mitigate\nthis limitation by treating all time steps equally and allowing models to focus on the most relevant observations. It\ncomputes the similarity between queries ( _q_ ) and keys ( _k_ ),\nscaling by the key dimension to keep gradients stable. MultiHead Attention (MHA) (Vaswani et al., 2017) extends this\nby allowing the model to attend to different representation\nsubspaces in parallel. Variants like Sparse Attention (Tay\net al., 2020; Roy et al., 2021), BigBird (Zaheer et al., 2020),\nand Longformer (Beltagy et al., 2020) modify the attention\npattern to reduce computational cost, particularly for long sequences, by attending only to selected positions rather than\nall pairs. Even with these improvements, attention-based\nmethods still rely on discrete scaled dot-product operations,\nlimiting their ability to model continuous trajectories often\ncaptured by CT counterparts.\nRecent work has explored bridging this gap through NeuralODE (Chen et al., 2018) formulation. mTAN (Shukla &\nMarlin, 2021) learns CT embeddings and uses time-based\nattention to interpolate irregular observations into a fixedlength representation for downstream encoder-decoder modeling. ODEFormer (d’Ascoli et al., 2023) trains a sequenceto-sequence transformer on synthetic trajectories to directly\ninfer symbolic ODE systems from noisy, irregular data,\nthough it struggles with chaotic systems and generalization\n\n\n\n1\n\n\n**Neuronal Attention Circuit (NAC) for Representation Learning**\n\n\n\nbeyond observed conditions. Continuous-time Attention\n(CTA) (Chien & Chen, 2021) embeds a continuous-time\nattention mechanism within a Neural ODE, allowing attention weights and hidden states to evolve jointly over time.\nStill, it remains computationally intensive and sensitive to\nthe accuracy of the ODE solver. ContiFormer (Chen et al.,\n2023) builds a CT-transformer by pairing ODE-defined latent trajectories with a time-aware attention mechanism to\nmodel dynamic relationships in data.\nDespite these innovations, a persistent and underexplored\ngap remains in developing a biologically plausible attention\nmechanism that seamlessly integrates CT dynamics with the\nabstraction of the brain’s connectome to handle irregular sequences without prohibitive computational costs. Building\non this, we propose a novel attention mechanism called the\n_Neuronal Attention Circuit_ (NAC), in which attention logits\nare computed as the solution to a first-order ODE modulated\nby nonlinear, interlinked gates derived from repurposing\nNeuronal Circuit Policies (NCPs) from the nervous system\nof _C. elegans_ nematode (refer to Appendix A.2 for more\ninformation). Unlike standard attention, which projects keyquery pairs through a dense layer, NAC employs a sensory\ngate to transform input features and a backbone to model\nnonlinear interactions, with multiple heads producing outputs structured for attention logits computation. Based on\nthe solutions to ODE, we define three computation modes:\n(i) Exact, using the closed-form ODE solution; (ii) Euler,\napproximating the solution via _explicit Euler_ integration;\nand (iii) Steady, using only the steady-state solution, analogous to standard attention scores. To reduce computational\ncomplexity, we implemented a sparse Top- _K_ pairwise concatenation algorithm that selectively curates key-query inputs. We evaluate NAC across multiple domains, including\nirregularly sampled time series, autonomous vehicle lanekeeping, and Industry 4.0, comparing it to state-of-the-art\nbaselines. NAC consistently matches or outperforms these\nmodels, while runtime and peak memory benchmarks place\nit between CT-RNNs in terms of speed and CT-Attentions\nin terms of memory requirements.\n\n\n**2. Neuronal Attention Circuit (NAC)**\n\n\nWe propose a simple alternative formulation of the attention\nlogits _a_ (refer to Appendix A.1 for more information), interpreting them as the solution to a first-order linear ODE\nmodulated by nonlinear, interlinked gates:\n\n\n\nfrom repurposing NCPs. We refer to this formulation as\nthe Neuronal Attention Circuit (NAC). It enables the logits\n_at_ to evolve dynamically with input-dependent, variable\ntime constants, mirroring the adaptive temporal dynamics\nfound in _C. elegans_ nervous systems while improving\ncomputational efficiency and expressiveness. Moreover, it\nintroduces continuous depth into the attention mechanism,\nbridging discrete-layer computation with dynamic temporal\nevolution.\n\n**Motivation behind this formulation:** The proposed\nformulation is loosely motivated by the input-dependent\ntime-constant mechanism of Liquid Neural Networks\n(LNNs), a class of CT-RNNs inspired by biological nervous\nsystems and synaptic transmission. In this framework, the\ndynamics of non-spiking neurons are described by a linear\nODE with nonlinear, interlinked gates: _ddt_ **xt** = **[x]** _τ_ **[t]** [+] **[ S][t]** _[,]_"}, {"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_3", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl", "metadata": {"source": "neuronal_attention_circuits_raw.md", "chunk_id": "neuronal_attention_circuits_raw_chunks_2k_3", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}, "text": "Scores: _S ←_ _Q · K_ _[⊤]_\n\nEffective Top- _K_ : _K_ eff _←_ min( _K, Tk_ )\nIndices: _I_ topk _←_ top ~~k~~ ( _S, K_ eff)\nGather: _K_ selected _←_ gather( _K, I_ topk) _∈_ R _[B][×][H][×][T][q]_ _[×][K]_ [eff] _[×][D]_\n\nTiled: _Q_ tiled _←_ tile( _Q, K_ eff) _∈_ R _[B][×][H][×][T][q]_ _[×][K]_ [eff] _[×][D]_\n\nConcatenate: _U_ topk _←_ [ _Q_ tiled; _K_ selected ] _∈_ R _[B][×][H][×][T][q]_ _[×][K]_ [eff] _[×]_ [2] _[D]_\n\n**return** _U_ topk\n\n\n**2.2. Designing the Neural Network**\n\n\nWe now outline the design of a neural network layer guided\nby the preceding analysis. The process involves five steps:\n(i) repurposing NCPs; (ii) input curation; (iii) construction\nof the time vector ( _t_ ); (iv) computing attention logits and\nweights; and (v) generating the attention output. Figure 2\nprovides a graphical overview of NAC.\n**Repurposing NCPs:** We repurpose the NCPs framework\nby converting its fixed, biologically derived wiring (see Figure 1(a)) into a flexible recurrent architecture that allows\nconfigurable input–output mappings. Instead of enforcing\na static connectome, our approach exposes adjacency matrices as modifiable structures defining sparse input and\nrecurrent connections. This enables selective information\n\nrouting across neuron groups while retaining the original circuit topology. Decoupling wiring specifications from model\ninstantiation allows dynamic connectivity adjustments to\naccommodate different input modalities without full retraining. Algorithm 1 summarizes the steps for repurposing the\nNCPs wiring mechanism. Key features include group-wise\nmasking for neuron isolation, adaptive remapping of inputs\nand outputs for task-specific adaptation, and tunable sparsity\n_s_ to balance expressiveness and efficiency.\nIn our implementation, the sensory neuron gate ( _NN_ sensory)\nprojects the _q_, _k_, and _v_ representations (see Figure 1(b)).\nThis enables sensory neurons to maintain structured, contextaware representations rather than collapsing inputs into fully\n\n\n\nconnected layers. As a result, the network preserves locality\nand modularity, which improves information routing.\n\n\n_NN_ sensory = NCPCell( _G_ input = [ _Ns_ ] _, G_ output = [ _Ns_ ] _,_\n\n_D_ = [ _Ni, Nc, Nm_ ] _, s_ )\n(13)\nThe inter-to-motor pathways form a backbone network\n( _NN_ backbone) with branches that compute _ϕ_ and _ωτ_ (see\nFigure 1(c)). Instead of learning _ϕ_ and _ωτ_ independently,\nthis backbone allows the model to learn shared representations, enabling multiple benefits: (i) separate head layers\nenable the system to capture temporal and structural dependencies independently; (ii) accelerates convergence during\ntraining.\n\n\n_NN_ backbone = NCPCell( _G_ input = [ _Ni_ ] _, G_ output = [ _Nm_ ] _,_\n\n_D_ = [ _Ns_ ] _, s_ )\n(14)\nThe output heads are defined as:\n\n\n_ϕ_ = _σ_ ( _NN_ backbone( **u** )) (15)\n\n_ωτ_ = softplus( _NN_ backbone( **u** )) + _ε,_ _ε >_ 0 (16)\n\n\nHere, _ϕ_ serves as a _content–target gate_ head, where the\nsigmoid function _σ_ ( _·_ ) determines the target signal strength.\nIn contrast, _ωτ_ is a strictly positive _time–constant gate_ head\nthat controls the rate of convergence and the steady-state\namplitude. Conceptually, this parallels recurrent gating: _ϕ_\nregulates _what_ content to emphasize, while _ωτ_ governs _how_\n_quickly_ and _to what extent_ it is expressed.\n**Input Curation:** We experimented with different\nstrategies for constructing query–key inputs. Initially, we implemented full pairwise concatenation,\nwhere queries _Q ∈_ R _[B][×][H][×][T][q][×][D]_ are combined with\nall keys _K_ _∈_ R _[B][×][H][×][T][k][×][D]_ to form a joint tensor\n_U ∈_ R _[B][×][H][×][T][q][×][T][k][×]_ [2] _[D]_ . While this preserved complete\nfeature information and enabled expressive, learnable\nsimilarity functions, it was memory-intensive, making it impractical for longer sequences. To mitigate this, we applied\na sparse Top- _K_ optimization: for each query, we compute\npairwise scores _S_ = _Q · K_ _[⊤]_ _∈_ R _[B][×][H][×][T][q][×][T][k]_, select the\nTop- _K_ eff = min( _K, Tk_ ) keys, and construct concatenated\npairs _U_ topk _∈_ R _[B][×][H][×][T][q][×][K]_ [eff] _[×]_ [2] _[D]_ . This approach preserves\nthe most relevant interactions while substantially reducing\nmemory requirements in the concatenation and subsequent\nbackbone processing stages, allowing the method to scale\nlinearly with the sequence length in those components.\nHowever, the initial computation of _S_ remains quadratic\n(see Appendix C.3). Algorithm 2 outlines the steps required\nfor input curation.\n**Time Vector:** NAC builds on continuous-depth models\nas (Hasani et al., 2022) that adapt their temporal dynamics to the task. It constructs an internal, normalized\npseudo-time vector _t_ pseudo using a sigmoidal transformation,\n_t_ pseudo = _σ_ ( _ta · t_ + _tb_ ), where _ta_ and _tb_ are learnable affine\n\n\n\n4\n\n\n**Neuronal Attention Circuit (NAC) for Representation Learning**\n\n\n\nparameters and _σ_ is the sigmoid function. For time-varying\ndatasets (e.g., irregularly sampled series), each time point\n_t_ is derived from the sample’s timestamp, while for tasks\nwithout meaningful timing, _t_ is set to 1. The resulting _t_ pseudo\nlies in [0 _,_ 1] and provides a smooth, bounded representation\nof time for modulating the network’s dynamics.\n**Attention logits and weights:** Starting from Eqn. 3,\nconsider the trajectory of a query–key pair with initial\ncondition _a_ 0 = 0:\n\n\n\n_at_ = _[ϕ]_\n\n_ωτ_\n\n\n\n�1 _−_ _e_ _[−][ω][τ][ t]_ [�] _,_ (17)\n\n\n\nfollowed by the _softmax_ normalization to calculate attention weights. The resulting attention weights _αt_ [(] _[h]_ [)] are then\nused to integrate with the value vector _v_ [(] _[h]_ [)], producing headspecific attention outputs. Finally, these outputs are concatenated and linearly projected back into the model dimension.\nThis formulation ensures that each head learns distinct dynamic compatibilities governed by its own parameterization\nof _ϕ_ and _ωτ_, while the aggregation across heads preserves\nthe expressive capacity of the standard multi-head attention\nmechanism.\n\n\n**2.3. NAC as Universal Approximator**\n\n\nWe now establish the universal approximation capability of\nNAC by extending the classical Universal Approximation\nTheorem (UAT) (Nishijima, 2021) to the proposed mechanism. For brevity, we consider a network with a single\nNAC layer processing fixed-dimensional inputs, though the\nargument generalizes to sequences."}, {"chunk_id": "attention_is_all_you_need_raw_chunks_2k_0", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl", "metadata": {"source": "attention_is_all_you_need_raw.md", "chunk_id": "attention_is_all_you_need_raw_chunks_2k_0", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl"}, "text": "Provided proper attribution is provided, Google hereby grants permission to\nreproduce the tables and figures in this paper solely for use in journalistic or\nscholarly works.\n\n## **Attention Is All You Need**\n\n\n\n**Niki Parmar** _[∗]_\nGoogle Research\n```\nnikip@google.com\n\n```\n\n\n**Ashish Vaswani** _[∗]_\nGoogle Brain\n```\navaswani@google.com\n\n```\n\n**Llion Jones** _[∗]_\nGoogle Research\n```\n llion@google.com\n\n```\n\n\n**Noam Shazeer** _[∗]_\nGoogle Brain\n```\nnoam@google.com\n\n```\n\n\n**Jakob Uszkoreit** _[∗]_\nGoogle Research\n```\nusz@google.com\n\n```\n\n\n**Aidan N. Gomez** _[∗†]_\nUniversity of Toronto\n```\naidan@cs.toronto.edu\n\n```\n\n\n**Łukasz Kaiser** _[∗]_\nGoogle Brain\n```\nlukaszkaiser@google.com\n\n```\n\n\n**Illia Polosukhin** _[∗‡]_\n\n```\n             illia.polosukhin@gmail.com\n\n```\n\n**Abstract**\n\n\nThe dominant sequence transduction models are based on complex recurrent or\nconvolutional neural networks that include an encoder and a decoder. The best\nperforming models also connect the encoder and decoder through an attention\nmechanism. We propose a new simple network architecture, the Transformer,\nbased solely on attention mechanisms, dispensing with recurrence and convolutions\nentirely. Experiments on two machine translation tasks show these models to\nbe superior in quality while being more parallelizable and requiring significantly\nless time to train. Our model achieves 28.4 BLEU on the WMT 2014 Englishto-German translation task, improving over the existing best results, including\nensembles, by over 2 BLEU. On the WMT 2014 English-to-French translation task,\nour model establishes a new single-model state-of-the-art BLEU score of 41.8 after\ntraining for 3.5 days on eight GPUs, a small fraction of the training costs of the\nbest models from the literature. We show that the Transformer generalizes well to\nother tasks by applying it successfully to English constituency parsing both with\nlarge and limited training data.\n\n\n_∗_ Equal contribution. Listing order is random. Jakob proposed replacing RNNs with self-attention and started\nthe effort to evaluate this idea. Ashish, with Illia, designed and implemented the first Transformer models and\nhas been crucially involved in every aspect of this work. Noam proposed scaled dot-product attention, multi-head\nattention and the parameter-free position representation and became the other person involved in nearly every\ndetail. Niki designed, implemented, tuned and evaluated countless model variants in our original codebase and\ntensor2tensor. Llion also experimented with novel model variants, was responsible for our initial codebase, and\nefficient inference and visualizations. Lukasz and Aidan spent countless long days designing various parts of and\nimplementing tensor2tensor, replacing our earlier codebase, greatly improving results and massively accelerating\nour research.\n\n_†_ Work performed while at Google Brain.\n\n_‡_ Work performed while at Google Research.\n\n\n31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, USA.\n\n\n**1** **Introduction**\n\n\nRecurrent neural networks, long short-term memory [13] and gated recurrent [7] neural networks\nin particular, have been firmly established as state of the art approaches in sequence modeling and\ntransduction problems such as language modeling and machine translation [35, 2, 5]. Numerous\nefforts have since continued to push the boundaries of recurrent language models and encoder-decoder\narchitectures [38, 24, 15].\n\n\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates _ht_, as a function of the previous hidden state _ht−_ 1 and the input for position _t_ . This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples. Recent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\n\n\nAttention mechanisms have become an integral part of compelling sequence modeling and transduction models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19]. In all but a few cases [27], however, such attention mechanisms\nare used in conjunction with a recurrent network.\n\n\nIn this work we propose the Transformer, a model architecture eschewing recurrence and instead\nrelying entirely on an attention mechanism to draw global dependencies between input and output.\nThe Transformer allows for significantly more parallelization and can reach a new state of the art in\ntranslation quality after being trained for as little as twelve hours on eight P100 GPUs.\n\n\n**2** **Background**\n\n\nThe goal of reducing sequential computation also forms the foundation of the Extended Neural GPU\n\n[16], ByteNet [18] and ConvS2S [9], all of which use convolutional neural networks as basic building\nblock, computing hidden representations in parallel for all input and output positions. In these models,\nthe number of operations required to relate signals from two arbitrary input or output positions grows\nin the distance between positions, linearly for ConvS2S and logarithmically for ByteNet. This makes\nit more difficult to learn dependencies between distant positions [12]. In the Transformer this is\nreduced to a constant number of operations, albeit at the cost of reduced effective resolution due\nto averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as\ndescribed in section 3.2.\n\n\nSelf-attention, sometimes called intra-attention is an attention mechanism relating different positions\nof a single sequence in order to compute a representation of the sequence. Self-attention has been\nused successfully in a variety of tasks including reading comprehension, abstractive summarization,\ntextual entailment and learning task-independent sentence representations [4, 27, 28, 22].\n\n\nEnd-to-end memory networks are based on a recurrent attention mechanism instead of sequencealigned recurrence and have been shown to perform well on simple-language question answering and\nlanguage modeling tasks [34].\n\n\nTo the best of our knowledge, however, the Transformer is the first transduction model relying\nentirely on self-attention to compute representations of its input and output without using sequencealigned RNNs or convolution. In the following sections, we will describe the Transformer, motivate\nself-attention and discuss its advantages over models such as [17, 18] and [9].\n\n\n**3** **Model Architecture**\n\n\nMost competitive neural sequence transduction models have an encoder-decoder structure [5, 2, 35].\nHere, the encoder maps an input sequence of symbol representations ( _x_ 1 _, ..., xn_ ) to a sequence\nof continuous representations **z** = ( _z_ 1 _, ..., zn_ ). Given **z**, the decoder then generates an output\nsequence ( _y_ 1 _, ..., ym_ ) of symbols one element at a time. At each step the model is auto-regressive\n\n[10], consuming the previously generated symbols as additional input when generating the next.\n\n\n2\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-2-0.png)\n\nFigure 1: The Transformer - model architecture.\n\n\nThe Transformer follows this overall architecture using stacked self-attention and point-wise, fully\nconnected layers for both the encoder and decoder, shown in the left and right halves of Figure 1,\nrespectively.\n\n\n**3.1** **Encoder and Decoder Stacks**"}, {"chunk_id": "attention_functional_roles_raw_chunks_2k_0", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl", "metadata": {"source": "attention_functional_roles_raw.md", "chunk_id": "attention_functional_roles_raw_chunks_2k_0", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl"}, "text": "## - INVESTIGATING THE FUNCTIONAL ROLES OF ATTEN ### TION HEADS IN VISION LANGUAGE MODELS: EVI DENCE FOR REASONING MODULES\n\n**Yanbei Jiang** **[1]** _[∗]_ **Xueqi Ma** **[1]** _[∗]_ **Shu Liu** **[1]** **Sarah Monazam Erfani** **[1]**\n\n**Tongliang Liu** **[2]** **James Bailey** **[1]** **Jey Han Lau** **[1]** **Krista A. Ehinger** **[1]**\n\n1The University of Melbourne 2The University of Sydney\n_{_ yanbeij, xueqim, shu6 _}_ @student.unimelb.edu.au\n_{_ sarah.erfani, baileyj, jeyhan.lau, kris.ehinger _}_ @unimelb.edu.au\ntongliang.liu@sydney.edu.au\n\n\nABSTRACT\n\n\nDespite excelling on multimodal benchmarks, vision–language models (VLMs)\nlargely remain a black box. In this paper, we propose a novel interpretability framework to systematically analyze the internal mechanisms of VLMs, focusing on the functional roles of attention heads in multimodal reasoning. To\nthis end, we introduce CogVision, a dataset that decomposes complex multimodal questions into step-by-step subquestions designed to simulate human reasoning through a chain-of-thought paradigm, with each subquestion associated\nwith specific receptive or cognitive functions such as high-level visual reception and inference. Using a probing-based methodology, we identify attention\nheads that specialize in these functions and characterize them as functional heads.\nOur analysis across diverse VLM families reveals that these functional heads\nare universally sparse, vary in number and distribution across functions, and\nmediate interactions and hierarchical organization. Furthermore, intervention\nexperiments demonstrate their critical role in multimodal reasoning: removing\nfunctional heads leads to performance degradation, while emphasizing them enhances accuracy. These findings provide new insights into the cognitive organization of VLMs and suggest promising directions for designing models with more\nhuman-aligned perceptual and reasoning abilities. Code and data are available at\nhttps://github.com/YanbeiJiang/CogVision.\n\n\n1 INTRODUCTION\n\n\nLarge Vision-Language Models (VLMs) (Zhu et al., 2023; Liu et al., 2023; Lu et al., 2024a) have\ndemonstrated remarkable success across diverse multimodal tasks, ranging from image captioning\nto visual question answering. Although VLMs can solve mathematical reasoning problems with\nvisual context (as shown in Fig. 1), their internal mechanisms remain poorly understood.\n\n\nFor humans, solving such complex problems (illustrated in Fig. 1) typically requires the collaboration of vision and language, engaging multiple brain regions (Barsalou, 2014): the occipital lobe\nfor visual reception, capturing and processing the content of the images; the temporal lobe supports\nlong-term memory and the recall of relevant factual knowledge, such as chemical concentration formulas (Wheeler et al., 1997); and the parietal and prefrontal cortices are involved in higher-order\nreasoning (Hubbard et al., 2005), to produce the correct answer.\n\n\nRecent research in interpretability has begun probing the internal organization of large language\nmodels (LLMs), revealing specialized attention heads for specific functions (Wu et al.; Li et al.,\n2023a; Zheng et al.). In the case of VLMs, several studies (Kang et al., 2025; Bi et al., 2025) have\nidentified sparse attention heads with special functional roles in tasks such as grounding. However,\nstudying VLMs in complex, multi-step reasoning scenarios remains underexplored. A deeper under\n\n_∗_ Both authors contributed equally to this research.\n\n\n1\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-0.png)\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-1.png)\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-2.png)\n\n\n\nDecision making\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-3.png)\n\nHigh-level Vision Reception\n\n\n\nLanguage Knowledge Recall\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-5.png)\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-6.png)\n\n\n\nMath Reasoning\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-7.png)\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-4.png)\n\nOccipital lobe Temporal lobe Parietal lobe Frontal lobe\n\n\n\n\n\n\n\n\n\nBy dividing the number of Solution A has a higher\n\nparticles by the solvent concentration of A, Solution A.\n\n\n\n\n\n\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-8.png)\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-11.png)\n\nFigure 1: To answer a complex question, the human brain engages multiple regions, each performing\ndistinct cognitive functions. We investigate whether specific attention heads in large vision language\nmodels play analogous functional roles in generating responses.\n\n\nstanding of whether such specialized components exist, how they are organized, and what functional\nroles they play in multimodal reasoning is therefore critical.\n\n\nIn this paper, we propose a novel interpretability framework for systematically analyzing the functional roles of attention heads-parallel units in transformer models that compute token-to-token\nattention-an important component in VLMs, with a focus on their contributions to reception (perceptual processing) and cognition. To facilitate this, we introduce CogVision, a dataset that bridges the\ngap between model analysis and human cognitive processes. CogVision decomposes multimodal\nqueries into step-by-step subquestions, each aligned with specific cognitive functions (such as math\nreasoning, decision-masking), thus enabling a fine-grained evaluation of reasoning aligned with the\nchain-of-thought (CoT) paradigm. Leveraging CogVision, we develop a probing method to identify and characterize attention heads responsible for distinct cognitive operations across vision and\nlanguage within the transformer architecture.\n\n\nWe conduct extensive experiments on three major VLM families, including Intern (Zhu et al., 2025),\nQwen (Yang et al., 2025), and Gemma (Team et al., 2025) with different model scales. Our results\nreveal the existence of cognitive heads that consistently exhibit **universal**, **sparse**, and **intrinsic**\nproperties across architectures. Further analysis of the correlations among these functional heads\nreveals **cross-function interactions**, where a single head may support multiple functions or modalities, and uncovers a **hierarchical structure** in which lower-level functional heads modulate higherlevel ones, showing the complexity of neural networks (Barsalou, 2014; Ono et al., 2022).\n\n\nFurthermore, we validate the functional importance of these heads by showing that their removal\ndegrades performance on complex tasks and leads to specific error patterns, while their enhancement improves reasoning capabilities. Our findings provide compelling evidence that these attention\nheads play a critical role in multimodal reasoning. This insight not only deepens our understanding of the internal organization of VLMs but also suggests potential avenues for designing more\ninterpretable and cognitive-inspired multimodal AI systems.\n\n\n2 COGVISION\n\n\nIn this section, we present our dataset Cognitive Vision (CogVision) that contains cognitive process\nin multimodal reasoning. CogVision contains 1,409 main questions and 5,744 subquestions. Each\n\n\n2"}, {"chunk_id": "attention_functional_roles_raw_chunks_2k_2", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl", "metadata": {"source": "attention_functional_roles_raw.md", "chunk_id": "attention_functional_roles_raw_chunks_2k_2", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl"}, "text": "Let _Nt_ denote the number of tokens in the generated answer _a_ _[M]_ _i_ [. To isolate semantically informative]\ncontent relevant to reasoning, we select the top- _k_ most important tokens, determined by prompting\nQwen3-30B LLM (Yang et al., 2025), yielding an index set _Ik_ with _|Ik|_ = _k_ . For each index\n_j ∈Ik_, we extract the corresponding attention head activations _Xj_, and compute the averaged\nactivation feature for the _m_ -th head in layer _l_ as ¯ _x_ _[m]_ _l_ = _k_ [1] � _j ∈Ikxml_ [. This results in a full set of]\n\nhead-level features _X_ [¯] _i_ = _{x_ ¯ _[m]_ _l_ _[|][ l][ ∈]_ [1] _[, . . ., L, m][ ∈]_ [1] _[, . . ., M]_ _[}]_ [.]\n\n\n3.2 FUNCTION PROBING\n\n\nFor the dataset with _N_ subQAF triplets, we collect all activations to construct the probing dataset:\n\n\n_D_ probe = _{_ (¯ _x_ _[m]_ _l_ _[, c]_ [)] _[i][}][N]_ _i_ =1 _[, l][ ∈{]_ [1] _[, . . ., L][}][, m][ ∈{]_ [1] _[, . . ., M]_ _[}]_ (1)\n\n\nFor classification based on CogVision, the training set includes 1,124 main questions with 4,604\nsubQAF triplet, while the testing set has 285 main questions with 1,141 triplets. Our probe takes\nthe form _pθ_ ( _x_ _[m]_ _l_ [) = sigmoid (] _[⟨][θ, x][m]_ _l_ _[⟩]_ [)][. There is one probe per attention head per layer per function.]\nFor each target function, the probe is trained by treating the attention-head outputs that lead to\ncorrect answers for that function as the positive class, and those associated with correct answers\nfrom other functions as the negative class. To ensure data balance, we select an equal number of\nnegative samples to match the positive ones. Given prior findings suggesting that cognitive functions\nmay vary by layer depth (Zheng et al.), we incorporate layer-wise information by computing the\naverage activation ¯ _xl_ = _M_ 1 � _Mm_ =1 _[x]_ [¯] _l_ _[m]_ [for each layer. We then augment each head-level vector with]\n\n\n4\n\n\nits corresponding layer summary, resulting in enriched features _x_ _[m]_ _l_ _[′]_ = [¯ _x_ _[m]_ _l_ [; ¯] _[x][l]_ []][ for probing. The]\nimportance for each head are then calculated based on the accuracy of predicting target function. The\neffectiveness of top-k tokens and layer information, as well as the sensitivity analysis with respect\nto the parameter _k_ and the choice of LLM fused for top-k token extraction, and prompt format, can\nbe found in Appendix A.8.\n\n\n4 EXPERIMENTS\n\n\nWe conduct a series of experiments on three VLM families across various model scales, including\nIntern (Zhu et al., 2025) (InternVL3-8B and InternVL3-2B), Qwen (Yang et al., 2025) (Qwen2.5VL-7B and Qwen2.5-VL-3B), and Gemma (Team et al., 2025) (Gemma3-4B and Gemma3-2B).\nWe analyze the commonalities and differences of functional heads (Subsection 4.1), validate their\ncontributions (Subsection 4.2), and examine correlations, including cross-function interactions and\nhierarchical organization (Subsection 4.3). We also assess their causal impact on downstream reasoning tasks (Subsection 4.4). Results confirm the existence of sparse, function-specific heads and\nhighlight their critical contribution to structured cognitive processing within VLMs.\n\n\n4.1 PROPERTIES OF COGNITIVE HEADS\n\n\n**Sparsity, Universality, and Intrinsic Organization:** Fig 2 shows the heatmap of attention head\naccuracy across eight functions in Qwen2.5-VL-7B on the CogVision test set, revealing a sparse\ndistribution. In total, fewer than 7% of all heads achieve accuracies above 0.9 across the eight functions (about 2% for high-level visual reception and math reasoning, and less than 1% for the others),\nsuggesting that only a small subset of heads meaningfully contributes to different reasoning tasks.\nThese results demonstrate that VLMs rely on highly specialized, localized components for distinct\ncognitive abilities. Pearson correlations between head-activation heatmaps across the eight functions\n(Fig. 3) are generally low, confirming that different functions tend to depend on partially separable\nsubsets of heads. Moreover, this sparse functional organization is consistent across architectures\nand scales: heatmaps for five additional models (Appendix A.4) confirm its universality, and the\nrelatively high Pearson correlation coefficients between models further verify this consistency (in\nAppendix A.9). Within the same model family (e.g., Qwen2.5-VL-7B in Fig 2 vs. Qwen2.5-VL-3B\nin Fig 8), we observe similar distributions, suggesting that such specialization is intrinsic to VLMs.\n\n\n**Functional Personalization:** Beyond sparsity, attention heads exhibit a structured distribution\nacross model layers. Math-related heads are dispersed throughout the network, whereas inferencerelated heads appear more frequently in higher layers. This task-dependent localization suggests an\nemergent modular organization in which different layers support distinct cognitive operations. We\nalso observe notable variation in head counts across functions. For example, in the Qwen family,\nmath reasoning and high-level visual reception heads are more prevalent than others, reflecting differences in representational and computational complexity. Smaller models contain fewer functional\nheads compared to their larger counterparts.\n\n\n4.2 FUNCTIONAL CONTRIBUTIONS OF COGNITIVE HEADS\n\n\nAfter identifying the cognitive heads associated with each function, we examine their functional\nroles by evaluating the model’s behavior on the CogVision test set under targeted interventions. We\nperform head ablation by scaling the output of a specific attention head with a small factor _ϵ_ (e.g.,\n0.001), effectively suppressing its contribution:\n\n\n\n�\n\n\n\n_x_ [mask] _i_ = Softmax\n\n\n\n_Wq_ _[i][W][ iT]_ _k_\n� ~~�~~ _dk/n_\n\n\n\n\n_· ϵWv_ _[i]_ (2)\n\n\n\nSpecifically, we compare model performance when masking identified cognitive heads versus masking an equal number of randomly-selected heads. To quantify the impact, we employ both an LLMbased judge and an integrated accuracy metric. For LLM-based judge, we use LLM (Qwen3-30B\nLLM (Yang et al., 2025)) to judge the correctness of the output. For the integrated accuracy metric,\nan output is considered unaffected if its BLEU score (Papineni et al., 2002) exceeds 0.8, or if either\n\n\n5\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-5-0.png)\n\nFigure 2: The existence of cognitive heads in Qwen2.5-VL-7B responsible for eight distinct functions in complex reasoning tasks. The x-axis represents the head index, while the y-axis indicates\nthe layer index. The values denote head importance scores, capped at a cutoff of 0.60.\n\n\nFigure 3: Pearson Correlation between different functions across two models.\n\n\nthe ROUGE score (Chin-Yew, 2004) or the semantic similarity score surpasses 0.6. This provides a\ncomprehensive evaluation of performance degradation."}, {"chunk_id": "attention_is_all_you_need_raw_chunks_2k_1", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl", "metadata": {"source": "attention_is_all_you_need_raw.md", "chunk_id": "attention_is_all_you_need_raw_chunks_2k_1", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl"}, "text": "[10], consuming the previously generated symbols as additional input when generating the next.\n\n\n2\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-2-0.png)\n\nFigure 1: The Transformer - model architecture.\n\n\nThe Transformer follows this overall architecture using stacked self-attention and point-wise, fully\nconnected layers for both the encoder and decoder, shown in the left and right halves of Figure 1,\nrespectively.\n\n\n**3.1** **Encoder and Decoder Stacks**\n\n\n**Encoder:** The encoder is composed of a stack of _N_ = 6 identical layers. Each layer has two\nsub-layers. The first is a multi-head self-attention mechanism, and the second is a simple, positionwise fully connected feed-forward network. We employ a residual connection [11] around each of\nthe two sub-layers, followed by layer normalization [1]. That is, the output of each sub-layer is\nLayerNorm( _x_ + Sublayer( _x_ )), where Sublayer( _x_ ) is the function implemented by the sub-layer\nitself. To facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension _d_ model = 512.\n\n\n**Decoder:** The decoder is also composed of a stack of _N_ = 6 identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack. Similar to the encoder, we employ residual connections\naround each of the sub-layers, followed by layer normalization. We also modify the self-attention\nsub-layer in the decoder stack to prevent positions from attending to subsequent positions. This\nmasking, combined with fact that the output embeddings are offset by one position, ensures that the\npredictions for position _i_ can depend only on the known outputs at positions less than _i_ .\n\n\n**3.2** **Attention**\n\n\nAn attention function can be described as mapping a query and a set of key-value pairs to an output,\nwhere the query, keys, values, and output are all vectors. The output is computed as a weighted sum\n\n\n3\n\n\nScaled Dot-Product Attention Multi-Head Attention\n\n\nFigure 2: (left) Scaled Dot-Product Attention. (right) Multi-Head Attention consists of several\nattention layers running in parallel.\n\n\nof the values, where the weight assigned to each value is computed by a compatibility function of the\nquery with the corresponding key.\n\n\n**3.2.1** **Scaled Dot-Product Attention**\n\n\nWe call our particular attention \"Scaled Dot-Product Attention\" (Figure 2). The input consists of\nqueries and keys of dimension _dk_, and values of dimension _dv_ . We compute the dot products of the\nquery with all keys, divide each by _[√]_ _dk_, and apply a softmax function to obtain the weights on the\nvalues.\n\n\nIn practice, we compute the attention function on a set of queries simultaneously, packed together\ninto a matrix _Q_ . The keys and values are also packed together into matrices _K_ and _V_ . We compute\nthe matrix of outputs as:\n\n\nAttention( _Q, K, V_ ) = softmax( _[Q][K]_ _[T]_ ) _V_ (1)\n\n~~_√_~~ _dk_\n\n\nThe two most commonly used attention functions are additive attention [2], and dot-product (multiplicative) attention. Dot-product attention is identical to our algorithm, except for the scaling factor\nof ~~_√_~~ 1 _dk_ . Additive attention computes the compatibility function using a feed-forward network with\na single hidden layer. While the two are similar in theoretical complexity, dot-product attention is\nmuch faster and more space-efficient in practice, since it can be implemented using highly optimized\nmatrix multiplication code.\n\n\nWhile for small values of _dk_ the two mechanisms perform similarly, additive attention outperforms\ndot product attention without scaling for larger values of _dk_ [3]. We suspect that for large values of\n_dk_, the dot products grow large in magnitude, pushing the softmax function into regions where it has\nextremely small gradients [4] . To counteract this effect, we scale the dot products by ~~_√_~~ 1 _dk_ .\n\n\n**3.2.2** **Multi-Head Attention**\n\n\nInstead of performing a single attention function with _d_ model-dimensional keys, values and queries,\nwe found it beneficial to linearly project the queries, keys and values _h_ times with different, learned\nlinear projections to _dk_, _dk_ and _dv_ dimensions, respectively. On each of these projected versions of\nqueries, keys and values we then perform the attention function in parallel, yielding _dv_ -dimensional\n\n\n4To illustrate why the dot products get large, assume that the components of _q_ and _k_ are independent random\nvariables with mean 0 and variance 1. Then their dot product, _q · k_ = [�] _[d]_ _i_ =1 _[k]_ _[q][i][k][i]_ [, has mean][ 0][ and variance] _[ d][k]_ [.]\n\n\n4\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-3-0.png)\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-3-1.png)\noutput values. These are concatenated and once again projected, resulting in the final values, as\ndepicted in Figure 2.\n\n\nMulti-head attention allows the model to jointly attend to information from different representation\nsubspaces at different positions. With a single attention head, averaging inhibits this.\n\n\nMultiHead( _Q, K, V_ ) = Concat(head1 _, ...,_ headh) _W_ _[O]_\n\nwhere headi = Attention( _QWi_ _[Q][, KW][ K]_ _i_ _[, V W][ V]_ _i_ [)]\n\n\nWhere the projections are parameter matrices _Wi_ _[Q]_ _∈_ R _[d]_ [model] _[×][d][k]_, _Wi_ _[K]_ _∈_ R _[d]_ [model] _[×][d][k]_, _Wi_ _[V]_ _∈_ R _[d]_ [model] _[×][d][v]_\nand _W_ _[O]_ _∈_ R _[hd][v][×][d]_ [model] .\n\n\nIn this work we employ _h_ = 8 parallel attention layers, or heads. For each of these we use\n_dk_ = _dv_ = _d_ model _/h_ = 64. Due to the reduced dimension of each head, the total computational cost\nis similar to that of single-head attention with full dimensionality.\n\n\n**3.2.3** **Applications of Attention in our Model**\n\n\nThe Transformer uses multi-head attention in three different ways:\n\n\n    - In \"encoder-decoder attention\" layers, the queries come from the previous decoder layer,\nand the memory keys and values come from the output of the encoder. This allows every\nposition in the decoder to attend over all positions in the input sequence. This mimics the\ntypical encoder-decoder attention mechanisms in sequence-to-sequence models such as\n\n[38, 2, 9].\n\n\n    - The encoder contains self-attention layers. In a self-attention layer all of the keys, values\nand queries come from the same place, in this case, the output of the previous layer in the\nencoder. Each position in the encoder can attend to all positions in the previous layer of the\nencoder.\n\n\n    - Similarly, self-attention layers in the decoder allow each position in the decoder to attend to\nall positions in the decoder up to and including that position. We need to prevent leftward\ninformation flow in the decoder to preserve the auto-regressive property. We implement this\ninside of scaled dot-product attention by masking out (setting to _−∞_ ) all values in the input\nof the softmax which correspond to illegal connections. See Figure 2."}, {"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_4", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl", "metadata": {"source": "neuronal_attention_circuits_raw.md", "chunk_id": "neuronal_attention_circuits_raw_chunks_2k_4", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}, "text": "**2.3. NAC as Universal Approximator**\n\n\nWe now establish the universal approximation capability of\nNAC by extending the classical Universal Approximation\nTheorem (UAT) (Nishijima, 2021) to the proposed mechanism. For brevity, we consider a network with a single\nNAC layer processing fixed-dimensional inputs, though the\nargument generalizes to sequences.\n\n\n**Theorem 2** (Universal Approximation by NAC) **.** _Let K ⊂_\nR _[n]_ _be a compact set and f_ : _K →_ R _[m]_ _be a continuous_\n_function. For any ϵ >_ 0 _, there exists a neural network_\n_consisting of a single NAC layer, with sufficiently large_\n_model dimension dmodel, number of heads H, sparsity s,_\n_and nonlinear activations, such that the network’s output_\n_g_ : R _[n]_ _→_ R _[m]_ _satisfies_\n\n\nsup _∥f_ ( _x_ ) _−_ _g_ ( _x_ ) _∥_ _< ϵ._ (20)\n_x∈K_\n\n\n_The proof is provided in Appendix B.3._\n\n\n**3. Evaluation**\n\n\nWe evaluate the proposed architecture against a range of\nbaselines, including (DT & CT) RNN, (DT & CT) attention,\nand multiple NAC ablation configurations. Experiments\nare conducted across diverse domains, including irregular\ntime-series modeling, lane keeping of autonomous vehicles,\nand Industry 4.0 prognostics. All results are obtained using 5-fold cross-validation, where models are trained using\nBPTT (see Appendix C.2) on each fold and evaluated across\nall folds. We report the mean ( _µ_ ) and standard deviation ( _σ_ )\nto capture variability and quantify uncertainty in the predictions. Table 1 provides results for all experiments, and the\ndetails of the baselines, ablation, environment utilized, the\ndata curation and preprocessing, and neural network architectures for all experiments are provided in the Appendix\nD.3.\n\n\n**3.1. Irregular Time-series**\n\n\nWe evaluate the proposed architecture on two irregular timeseries datasets: (i) Event-based MNIST; and (ii) Person\nActivity Recognition (PAR).\n\n\n\nFor finite _t_, the exponential factor (1 _−_ _e_ _[−][ω][τ][ t]_ ) regulates the\nbuildup of attention, giving _ωτ_ a temporal gating role. Normalizing across all keys via _softmax_ yields attention weights\n_αt_ = softmax( _at_ ), defining a valid probability distribution\nwhere _ϕ_ amplifies or suppresses content alignments, and _ωτ_\nshapes both the speed and saturation of these preferences.\nAs _t →∞_, the trajectory converges to the steady state\n\n\n_a_ _[∗]_ _t_ [=] _[ϕ]_ _≈_ _[q][⊤][k]_ _,_ (18)\n\n_ωτ_ ~~_√_~~ _dk_\n\n\nwhich is analogous to scaled-dot attention under specific\nparameterization when the backbone _NN_ backbone is configured as a linear projection such that _ϕ_ ( **u** ) = _q_ _[⊤]_ _k_ and\n_ωτ_ ( _u_ ) = _[√]_ _dk_ (e.g., by setting NCP weights to emulate\nbilinear forms and disabling nonlinearities). In general, the\nnonlinear backbone allows for more expressive similarities,\nwith the approximation holding when trained to mimic dot\nproducts.\n**Attention output:** Finally, the attention output is computed\nby integrating the attention weights with the value matrix:\n\n\nNAC( _q, k, v_ ) = _αtvtdt_ (19)\n� _T_\n\n\nIn practice, the integration is approximated using a Riemannstyle approach, where the weighted elements are computed\nby multiplying each _vt_ with its corresponding _αt_ . These are\nthen summed and multiplied by a fixed pseudo-time step\n_δt_, chosen as a scalar (typically between 0.5–1.0) hyperparameter during layer initialization. This yields a continuous\nanalogue of standard weighted sums, giving finer resolution\nof the attention trajectory without altering the underlying\nvalues. Sensitivity to attention output w.r.t _δt_ is visualized\nin Appendix D.2.\n\n\n2.2.1. EXTENSION TO MULTI-HEAD\n\n\nTo scale this mechanism to multi-head attention, we project\nthe input sequence into _H_ independent subspaces (heads)\nof dimension _d_ model _/H_, yielding query, key, and value tensors ( _q_ [(] _[h]_ [)] _, k_ [(] _[h]_ [)] _, v_ [(] _[h]_ [)] ) for _h ∈{_ 1 _, . . ., H}_ . For each head,\npairwise logits are computed according to Eqns. 2,3 or 18,\n\n\n\n5\n\n\n**Neuronal Attention Circuit (NAC) for Representation Learning**\n\n\n_Figure 2._ Illustration of the architecture of **(a)** Neuronal Attention Circuit mechanism ; **(b)** Multi-Head Extension\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/neuronal_attention_circuits.pdf-5-0.png)\n\n**Event-based MNIST:** Event-based MNIST is the trans\nformation of the widely recognized MNIST dataset with\nirregular sampling added originally proposed in (Lechner\n& Hasani, 2022). The transformation was done in two\nsteps: (i) flattening each 28×28 image into a time series\nof length 784, and (ii) encoding the binary time series into\nan event-based format by collapsing consecutive identical\nvalues (e.g., 1,1,1,1 → (1, t=4)). This representation requires models to handle temporal dependencies effectively.\nNAC-PW achieved first place with an accuracy of 96.64%,\nfollowed by NAC-Exact/05s/8k at 96.12%. GRU-ODE and\nContiFormer ranked third with 96.04%.\n\n**Person Activity Recognition (PAR):** We employed the\nLocalized Person Activity dataset from UC Irvine (Vidulin\net al., 2010). The dataset contains data from five participants,\neach equipped with inertial measurement sensors sampled\nevery 211 ms. The goal of this experiment is to predict a\nperson’s activity from a set of predefined actions, making it\na classification task. All models performed well on this task,\nwith NAC-PW achieving 89.15% accuracy and taking first\nplace. NAC-Exact/05s/8k and GRU-ODE ranked second\nwith 89.01% accuracy, while NAC-02s ranked third with\n88.84% mean accuracy.\n\n\n**3.2. Lane-Keeping of Autonomous Vehicles**\n\n\nLane keeping in autonomous vehicles (AVs) is a fundamental problem in robotics and AI. Early works (Tiang et al.,\n2018; Park et al., 2021) primarily emphasized accuracy,\noften relying on large models. More recent research (Lechner et al., 2020; Razzaq & Hongwei, 2023) has shifted toward designing compact architectures suitable for resourceconstrained devices. The goal of this experiment is to create\na long causal structure between the road’s horizon and the"}], "retrieved_graph_subgraph": {"nodes": [{"id": "Attention mechanism", "properties": {"id": "Attention mechanism"}, "labels": ["Concept"]}, {"id": "attention heads", "properties": {"id": "attention heads"}, "labels": ["Concept"]}, {"id": "attention patterns", "properties": {"id": "attention patterns"}, "labels": ["Concept"]}, {"id": "anaphora resolution", "properties": {"id": "anaphora resolution"}, "labels": ["Concept"]}, {"id": "Attention weights", "properties": {"id": "Attention weights"}, "labels": ["Concept"]}, {"id": "c35df05545627694d3b4bbf52619a5da", "properties": {"chunk_index": "0", "chunk_file": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl", "source_type": "chunk", "id": "c35df05545627694d3b4bbf52619a5da", "text": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_0", "source_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_0", "chunk_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_0"}, "labels": ["Document"]}, {"id": "888d0bd62e26d30498c9f50b218a6001", "properties": {"chunk_index": "2", "chunk_file": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl", "source_type": "chunk", "id": "888d0bd62e26d30498c9f50b218a6001", "text": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_2", "source_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_2", "chunk_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_2"}, "labels": ["Document"]}, {"id": "36f927c2ec5951b1af0611a9728d214b", "properties": {"derived_from_chunk_file": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl", "markdown_source": "attention_is_all_you_need_raw_with_image_ids_with_captions.md", "source_type": "markdown", "id": "36f927c2ec5951b1af0611a9728d214b", "text": "attention_is_all_you_need_raw_with_image_ids_with_captions.md::images", "source_id": "attention_is_all_you_need_raw_with_image_ids_with_captions.md::images"}, "labels": ["Document"]}, {"id": "img_attention_is_all_you_need_12_0", "properties": {"id": "img_attention_is_all_you_need_12_0", "source_path": "E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-12-0.png"}, "labels": ["Image"]}, {"id": "Transformer", "properties": {"id": "Transformer"}, "labels": ["Model"]}, {"id": "Encoder-decoder architectures", "properties": {"id": "Encoder-decoder architectures"}, "labels": ["Model"]}, {"id": "Active memory", "properties": {"id": "Active memory"}, "labels": ["Concept"]}, {"id": "93ec065e0391e99e3dd12c28af8c5ff9", "properties": {"chunk_index": "1", "chunk_file": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl", "source_type": "chunk", "id": "93ec065e0391e99e3dd12c28af8c5ff9", "text": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_1", "source_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_1", "chunk_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_1"}, "labels": ["Document"]}, {"id": "img_attention_is_all_you_need_13_0", "properties": {"id": "img_attention_is_all_you_need_13_0", "source_path": "E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-13-0.png"}, "labels": ["Image"]}, {"id": "img_attention_is_all_you_need_14_0", "properties": {"id": "img_attention_is_all_you_need_14_0", "source_path": "E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-14-0.png"}, "labels": ["Image"]}], "edges": [{"source": "c35df05545627694d3b4bbf52619a5da", "type": "MENTIONS", "properties": {}, "target": "Attention mechanism"}, {"source": "888d0bd62e26d30498c9f50b218a6001", "type": "MENTIONS", "properties": {}, "target": "Attention mechanism"}, {"source": "36f927c2ec5951b1af0611a9728d214b", "type": "MENTIONS", "properties": {}, "target": "Attention mechanism"}, {"source": "img_attention_is_all_you_need_12_0", "type": "DEPICTS", "properties": {}, "target": "Attention mechanism"}, {"source": "Transformer", "type": "BUILDS_ON", "properties": {}, "target": "Attention mechanism"}, {"source": "Encoder-decoder architectures", "type": "BUILDS_ON", "properties": {}, "target": "Attention mechanism"}, {"source": "Active memory", "type": "COMPARED_WITH", "properties": {}, "target": "Attention mechanism"}, {"source": "Transformer", "type": "EXTENDS", "properties": {}, "target": "Attention mechanism"}, {"source": "93ec065e0391e99e3dd12c28af8c5ff9", "type": "MENTIONS", "properties": {}, "target": "attention heads"}, {"source": "36f927c2ec5951b1af0611a9728d214b", "type": "MENTIONS", "properties": {}, "target": "attention heads"}, {"source": "img_attention_is_all_you_need_13_0", "type": "DEPICTS", "properties": {}, "target": "attention heads"}, {"source": "36f927c2ec5951b1af0611a9728d214b", "type": "MENTIONS", "properties": {}, "target": "attention patterns"}, {"source": "img_attention_is_all_you_need_13_0", "type": "DEPICTS", "properties": {}, "target": "attention patterns"}, {"source": "36f927c2ec5951b1af0611a9728d214b", "type": "MENTIONS", "properties": {}, "target": "anaphora resolution"}, {"source": "img_attention_is_all_you_need_13_0", "type": "DEPICTS", "properties": {}, "target": "anaphora resolution"}, {"source": "36f927c2ec5951b1af0611a9728d214b", "type": "MENTIONS", "properties": {}, "target": "Attention weights"}, {"source": "img_attention_is_all_you_need_14_0", "type": "DEPICTS", "properties": {}, "target": "Attention weights"}]}, "final_answer": "While the provided text and graph contexts indicate a relationship between anaphora resolution and attention mechanisms, neither source explicitly details *how* anaphora resolution is done using attention.\n\nThe graph context shows that \"anaphora resolution\" is a concept mentioned in relation to \"Attention mechanism\" within the \"Attention Is All You Need\" paper. This paper introduces the Transformer model, which relies solely on attention mechanisms.\n\nThe text context, primarily from the \"Attention Is All You Need\" paper, explains the general workings of attention mechanisms, particularly self-attention:\n*   **Self-attention layers** in the encoder allow each position to attend to all positions in the previous layer, enabling the model to relate different positions of a single sequence to compute a representation.\n*   **Self-attention layers** in the decoder allow each position to attend to all preceding positions.\n*   Attention mechanisms allow models to focus on the most relevant observations and model dependencies without regard to their distance in the input or output sequences. This ability to connect distant parts of a sequence is crucial for tasks like anaphora resolution, where a pronoun might refer to an entity far earlier in the text.\n*   The Transformer uses multi-head attention, which allows the model to jointly attend to information from different representation subspaces at different positions.\n\nAlthough the specific steps for anaphora resolution using attention are not detailed, the underlying principle is that attention mechanisms, especially self-attention, provide a way for models to identify and weigh the relevance of different words or phrases in a sequence to each other, which is fundamental for resolving anaphoric references.\n\n**Image paths:**\n*   img_attention_is_all_you_need_13_0 | E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-13-0.png\n*   img_attention_is_all_you_need_2_0 | E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-2-0.png\n*   img_attention_is_all_you_need_3_0 | E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-3-0.png\n*   img_attention_is_all_you_need_3_1 | E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-3-1.png\n*   img_attention_is_all_you_need_12_0 | E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-12-0.png\n*   img_attention_is_all_you_need_14_0 | E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-14-0.png\n\n**Chunks used:**\n*   attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_0 (source: attention_is_all_you_need_raw_with_image_ids_with_captions.md)\n*   attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_1 (source: attention_is_all_you_need_raw_with_image_ids_with_captions.md)\n*   attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_2 (source: attention_is_all_you_need_raw_with_image_ids_with_captions.md)", "token_usage": null, "latency_ms": {"rag": 3886, "graph": 10388, "synthesis": 8221, "total": 22502}, "internal": {"rag": {"query": "how is anaphora resolution done using attention mechanism?", "rewritten_or_decomposed_queries": ["anaphora resolution attention mechanism", "attention-based anaphora resolution models", "using attention for coreference resolution", "anaphora resolution with neural attention"], "k_per_subquery": 3, "retrieved_chunks": [{"chunk_id": "attention_is_all_you_need_raw_chunks_2k_2", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl", "metadata": {"source": "attention_is_all_you_need_raw.md", "chunk_id": "attention_is_all_you_need_raw_chunks_2k_2", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl"}, "text": "[38, 2, 9].\n\n\n    - The encoder contains self-attention layers. In a self-attention layer all of the keys, values\nand queries come from the same place, in this case, the output of the previous layer in the\nencoder. Each position in the encoder can attend to all positions in the previous layer of the\nencoder.\n\n\n    - Similarly, self-attention layers in the decoder allow each position in the decoder to attend to\nall positions in the decoder up to and including that position. We need to prevent leftward\ninformation flow in the decoder to preserve the auto-regressive property. We implement this\ninside of scaled dot-product attention by masking out (setting to _−∞_ ) all values in the input\nof the softmax which correspond to illegal connections. See Figure 2.\n\n\n**3.3** **Position-wise Feed-Forward Networks**\n\n\nIn addition to attention sub-layers, each of the layers in our encoder and decoder contains a fully\nconnected feed-forward network, which is applied to each position separately and identically. This\nconsists of two linear transformations with a ReLU activation in between.\n\n\nFFN( _x_ ) = max(0 _, xW_ 1 + _b_ 1) _W_ 2 + _b_ 2 (2)\n\n\nWhile the linear transformations are the same across different positions, they use different parameters\nfrom layer to layer. Another way of describing this is as two convolutions with kernel size 1.\nThe dimensionality of input and output is _d_ model = 512, and the inner-layer has dimensionality\n_dff_ = 2048.\n\n\n**3.4** **Embeddings and Softmax**\n\n\nSimilarly to other sequence transduction models, we use learned embeddings to convert the input\ntokens and output tokens to vectors of dimension _d_ model. We also use the usual learned linear transformation and softmax function to convert the decoder output to predicted next-token probabilities. In\nour model, we share the same weight matrix between the two embedding layers and the pre-softmax\nlinear transformation, similar to [30]. In the embedding layers, we multiply those weights by _[√]_ _d_ model.\n\n\n5\n\n\nTable 1: Maximum path lengths, per-layer complexity and minimum number of sequential operations\nfor different layer types. _n_ is the sequence length, _d_ is the representation dimension, _k_ is the kernel\nsize of convolutions and _r_ the size of the neighborhood in restricted self-attention.\n\n\nLayer Type Complexity per Layer Sequential Maximum Path Length\nOperations\nSelf-Attention _O_ ( _n_ [2] _· d_ ) _O_ (1) _O_ (1)\nRecurrent _O_ ( _n · d_ [2] ) _O_ ( _n_ ) _O_ ( _n_ )\nConvolutional _O_ ( _k · n · d_ [2] ) _O_ (1) _O_ ( _logk_ ( _n_ ))\nSelf-Attention (restricted) _O_ ( _r · n · d_ ) _O_ (1) _O_ ( _n/r_ )\n\n\n**3.5** **Positional Encoding**\n\n\nSince our model contains no recurrence and no convolution, in order for the model to make use of the\norder of the sequence, we must inject some information about the relative or absolute position of the\ntokens in the sequence. To this end, we add \"positional encodings\" to the input embeddings at the\nbottoms of the encoder and decoder stacks. The positional encodings have the same dimension _d_ model\nas the embeddings, so that the two can be summed. There are many choices of positional encodings,\nlearned and fixed [9].\n\n\nIn this work, we use sine and cosine functions of different frequencies:\n\n\n_PE_ ( _pos,_ 2 _i_ ) = _sin_ ( _pos/_ 10000 [2] _[i/d]_ [model] )\n\n_PE_ ( _pos,_ 2 _i_ +1) = _cos_ ( _pos/_ 10000 [2] _[i/d]_ [model] )\n\n\nwhere _pos_ is the position and _i_ is the dimension. That is, each dimension of the positional encoding\ncorresponds to a sinusoid. The wavelengths form a geometric progression from 2 _π_ to 10000 _·_ 2 _π_ . We\nchose this function because we hypothesized it would allow the model to easily learn to attend by\nrelative positions, since for any fixed offset _k_, _PEpos_ + _k_ can be represented as a linear function of\n_PEpos_ .\n\n\nWe also experimented with using learned positional embeddings [9] instead, and found that the two\nversions produced nearly identical results (see Table 3 row (E)). We chose the sinusoidal version\nbecause it may allow the model to extrapolate to sequence lengths longer than the ones encountered\nduring training.\n\n\n**4** **Why Self-Attention**\n\n\nIn this section we compare various aspects of self-attention layers to the recurrent and convolutional layers commonly used for mapping one variable-length sequence of symbol representations\n( _x_ 1 _, ..., xn_ ) to another sequence of equal length ( _z_ 1 _, ..., zn_ ), with _xi, zi ∈_ R _[d]_, such as a hidden\nlayer in a typical sequence transduction encoder or decoder. Motivating our use of self-attention we\nconsider three desiderata.\n\n\nOne is the total computational complexity per layer. Another is the amount of computation that can\nbe parallelized, as measured by the minimum number of sequential operations required.\n\n\nThe third is the path length between long-range dependencies in the network. Learning long-range\ndependencies is a key challenge in many sequence transduction tasks. One key factor affecting the\nability to learn such dependencies is the length of the paths forward and backward signals have to\ntraverse in the network. The shorter these paths between any combination of positions in the input\nand output sequences, the easier it is to learn long-range dependencies [12]. Hence we also compare\nthe maximum path length between any two input and output positions in networks composed of the\ndifferent layer types.\n\n\nAs noted in Table 1, a self-attention layer connects all positions with a constant number of sequentially\nexecuted operations, whereas a recurrent layer requires _O_ ( _n_ ) sequential operations. In terms of\ncomputational complexity, self-attention layers are faster than recurrent layers when the sequence\n\n\n6\n\n\nlength _n_ is smaller than the representation dimensionality _d_, which is most often the case with\nsentence representations used by state-of-the-art models in machine translations, such as word-piece\n\n[38] and byte-pair [31] representations. To improve computational performance for tasks involving\nvery long sequences, self-attention could be restricted to considering only a neighborhood of size _r_ in\nthe input sequence centered around the respective output position. This would increase the maximum\npath length to _O_ ( _n/r_ ). We plan to investigate this approach further in future work.\n\n\nA single convolutional layer with kernel width _k < n_ does not connect all pairs of input and output\npositions. Doing so requires a stack of _O_ ( _n/k_ ) convolutional layers in the case of contiguous kernels,\nor _O_ ( _logk_ ( _n_ )) in the case of dilated convolutions [18], increasing the length of the longest paths\nbetween any two positions in the network. Convolutional layers are generally more expensive than\nrecurrent layers, by a factor of _k_ . Separable convolutions [6], however, decrease the complexity\nconsiderably, to _O_ ( _k · n · d_ + _n · d_ [2] ). Even with _k_ = _n_, however, the complexity of a separable\nconvolution is equal to the combination of a self-attention layer and a point-wise feed-forward layer,\nthe approach we take in our model.\n\n\nAs side benefit, self-attention could yield more interpretable models. We inspect attention distributions\nfrom our models and present and discuss examples in the appendix. Not only do individual attention\nheads clearly learn to perform different tasks, many appear to exhibit behavior related to the syntactic\nand semantic structure of the sentences.\n\n\n**5** **Training**\n\n\nThis section describes the training regime for our models.\n\n\n**5.1** **Training Data and Batching**"}, {"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_0", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl", "metadata": {"source": "neuronal_attention_circuits_raw.md", "chunk_id": "neuronal_attention_circuits_raw_chunks_2k_0", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}, "text": "## **Neuronal Attention Circuit (NAC) for Representation Learning**\n\n**Waleed Razzaq** [1] **Izis Kankaraway** [1] **Yun-Bo Zhao** [1 2]\n\n\n\n**Abstract**\n\nAttention improves representation learning over\nRNNs, but its discrete nature limits continuoustime (CT) modeling. We introduce Neuronal Attention Circuit (NAC), a novel, biologically plausible CT-Attention mechanism that reformulates\n\nattention logits computation as the solution to a\nlinear first-order ODE with nonlinear interlinked\ngates derived from repurposing _C. elegans_ Neuronal Circuit Policies (NCPs) wiring mechanism.\nNAC replaces dense projections with sparse sensory gates for key-query projections and a sparse\nbackbone network with two heads for computing\n_content-target_ and _learnable time-constant_ gates,\nenabling efficient adaptive dynamics. NAC supports three attention logit computation modes: (i)\nexplicit Euler integration, (ii) exact closed-form\nsolution, and (iii) steady-state approximation. To\nimprove memory intensity, we implemented a\nsparse Top- _K_ pairwise concatenation scheme that\nselectively curates key-query interactions. We\nprovide rigorous theoretical guarantees, including\nstate stability, bounded approximation errors, and\nuniversal approximation. Empirically, we implemented NAC in diverse domains, including irregular time-series classification, lane-keeping for\nautonomous vehicles, and industrial prognostics.\nWe observed that NAC matches or outperforms\ncompeting baselines in accuracy and occupies an\nintermediate position in runtime and memory efficiency compared with several CT baselines.\n\n\n**1. Introduction**\n\n\nLearning representations of sequential data in temporal or\nspatio-temporal domains is essential for capturing patterns\nand enabling accurate forecasting. Discrete-time Recurrent neural networks (DT-RNNs) such as RNN (Rumelhart et al., 1985; Jordan, 1997), Long-short term memory\n\n\n1Department of Automation, University of Science & Technology of China, Hefei, China [2] Institute of Artificial Intelligence,\nHefei Comprehensive National Science Center. Correspondence to:\nYun-Bo Zhao _<_ ybzhao@ustc.edu.cn _>_, Waleed Razzaq _<_ waleedrazzaq@mail.ustc.edu.cn _>_ .\n\n\n_Preprint. December 12, 2025._\n\n\n\n(LSTM) (Hochreiter & Schmidhuber, 1997), and Gated Recurrent Unit (GRU) (Cho et al., 2014) model sequential dependencies by iteratively updating hidden states to represent\nor predict future elements in a sequence. While effective\nfor regularly sampled sequences, DT-RNNs face challenges\nwith irregularly sampled data because they assume uniform\ntime intervals. In addition, vanishing gradients can make\nit difficult to capture long-term dependencies (Hochreiter,\n1998).\nContinuous-time RNNs (CT-RNNs) (Rubanova et al., 2019)\nmodel hidden states as ordinary differential equations\n(ODEs), allowing them to process inputs that arrive at arbitrary or irregular time intervals. Mixed-memory RNNs\n(mmRNNs) (Lechner & Hasani, 2022) build on this idea\nby separating memory compartments from time-continuous\nstates, helping maintain stable error propagation while capturing continuous-time dynamics. Liquid neural networks\n(LNNs) (Hasani et al., 2021; 2022) take a biologically inspired approach by assigning variable time-constants to hidden states, improving adaptability and robustness, though\nvanishing gradients can still pose challenges during training.\nThe attention mechanisms (Vaswani et al., 2017) mitigate\nthis limitation by treating all time steps equally and allowing models to focus on the most relevant observations. It\ncomputes the similarity between queries ( _q_ ) and keys ( _k_ ),\nscaling by the key dimension to keep gradients stable. MultiHead Attention (MHA) (Vaswani et al., 2017) extends this\nby allowing the model to attend to different representation\nsubspaces in parallel. Variants like Sparse Attention (Tay\net al., 2020; Roy et al., 2021), BigBird (Zaheer et al., 2020),\nand Longformer (Beltagy et al., 2020) modify the attention\npattern to reduce computational cost, particularly for long sequences, by attending only to selected positions rather than\nall pairs. Even with these improvements, attention-based\nmethods still rely on discrete scaled dot-product operations,\nlimiting their ability to model continuous trajectories often\ncaptured by CT counterparts.\nRecent work has explored bridging this gap through NeuralODE (Chen et al., 2018) formulation. mTAN (Shukla &\nMarlin, 2021) learns CT embeddings and uses time-based\nattention to interpolate irregular observations into a fixedlength representation for downstream encoder-decoder modeling. ODEFormer (d’Ascoli et al., 2023) trains a sequenceto-sequence transformer on synthetic trajectories to directly\ninfer symbolic ODE systems from noisy, irregular data,\nthough it struggles with chaotic systems and generalization\n\n\n\n1\n\n\n**Neuronal Attention Circuit (NAC) for Representation Learning**\n\n\n\nbeyond observed conditions. Continuous-time Attention\n(CTA) (Chien & Chen, 2021) embeds a continuous-time\nattention mechanism within a Neural ODE, allowing attention weights and hidden states to evolve jointly over time.\nStill, it remains computationally intensive and sensitive to\nthe accuracy of the ODE solver. ContiFormer (Chen et al.,\n2023) builds a CT-transformer by pairing ODE-defined latent trajectories with a time-aware attention mechanism to\nmodel dynamic relationships in data.\nDespite these innovations, a persistent and underexplored\ngap remains in developing a biologically plausible attention\nmechanism that seamlessly integrates CT dynamics with the\nabstraction of the brain’s connectome to handle irregular sequences without prohibitive computational costs. Building\non this, we propose a novel attention mechanism called the\n_Neuronal Attention Circuit_ (NAC), in which attention logits\nare computed as the solution to a first-order ODE modulated\nby nonlinear, interlinked gates derived from repurposing\nNeuronal Circuit Policies (NCPs) from the nervous system\nof _C. elegans_ nematode (refer to Appendix A.2 for more\ninformation). Unlike standard attention, which projects keyquery pairs through a dense layer, NAC employs a sensory\ngate to transform input features and a backbone to model\nnonlinear interactions, with multiple heads producing outputs structured for attention logits computation. Based on\nthe solutions to ODE, we define three computation modes:\n(i) Exact, using the closed-form ODE solution; (ii) Euler,\napproximating the solution via _explicit Euler_ integration;\nand (iii) Steady, using only the steady-state solution, analogous to standard attention scores. To reduce computational\ncomplexity, we implemented a sparse Top- _K_ pairwise concatenation algorithm that selectively curates key-query inputs. We evaluate NAC across multiple domains, including\nirregularly sampled time series, autonomous vehicle lanekeeping, and Industry 4.0, comparing it to state-of-the-art\nbaselines. NAC consistently matches or outperforms these\nmodels, while runtime and peak memory benchmarks place\nit between CT-RNNs in terms of speed and CT-Attentions\nin terms of memory requirements.\n\n\n**2. Neuronal Attention Circuit (NAC)**\n\n\nWe propose a simple alternative formulation of the attention\nlogits _a_ (refer to Appendix A.1 for more information), interpreting them as the solution to a first-order linear ODE\nmodulated by nonlinear, interlinked gates:\n\n\n\nfrom repurposing NCPs. We refer to this formulation as\nthe Neuronal Attention Circuit (NAC). It enables the logits\n_at_ to evolve dynamically with input-dependent, variable\ntime constants, mirroring the adaptive temporal dynamics\nfound in _C. elegans_ nervous systems while improving\ncomputational efficiency and expressiveness. Moreover, it\nintroduces continuous depth into the attention mechanism,\nbridging discrete-layer computation with dynamic temporal\nevolution.\n\n**Motivation behind this formulation:** The proposed\nformulation is loosely motivated by the input-dependent\ntime-constant mechanism of Liquid Neural Networks\n(LNNs), a class of CT-RNNs inspired by biological nervous\nsystems and synaptic transmission. In this framework, the\ndynamics of non-spiking neurons are described by a linear\nODE with nonlinear, interlinked gates: _ddt_ **xt** = **[x]** _τ_ **[t]** [+] **[ S][t]** _[,]_"}, {"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_3", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl", "metadata": {"source": "neuronal_attention_circuits_raw.md", "chunk_id": "neuronal_attention_circuits_raw_chunks_2k_3", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}, "text": "Scores: _S ←_ _Q · K_ _[⊤]_\n\nEffective Top- _K_ : _K_ eff _←_ min( _K, Tk_ )\nIndices: _I_ topk _←_ top ~~k~~ ( _S, K_ eff)\nGather: _K_ selected _←_ gather( _K, I_ topk) _∈_ R _[B][×][H][×][T][q]_ _[×][K]_ [eff] _[×][D]_\n\nTiled: _Q_ tiled _←_ tile( _Q, K_ eff) _∈_ R _[B][×][H][×][T][q]_ _[×][K]_ [eff] _[×][D]_\n\nConcatenate: _U_ topk _←_ [ _Q_ tiled; _K_ selected ] _∈_ R _[B][×][H][×][T][q]_ _[×][K]_ [eff] _[×]_ [2] _[D]_\n\n**return** _U_ topk\n\n\n**2.2. Designing the Neural Network**\n\n\nWe now outline the design of a neural network layer guided\nby the preceding analysis. The process involves five steps:\n(i) repurposing NCPs; (ii) input curation; (iii) construction\nof the time vector ( _t_ ); (iv) computing attention logits and\nweights; and (v) generating the attention output. Figure 2\nprovides a graphical overview of NAC.\n**Repurposing NCPs:** We repurpose the NCPs framework\nby converting its fixed, biologically derived wiring (see Figure 1(a)) into a flexible recurrent architecture that allows\nconfigurable input–output mappings. Instead of enforcing\na static connectome, our approach exposes adjacency matrices as modifiable structures defining sparse input and\nrecurrent connections. This enables selective information\n\nrouting across neuron groups while retaining the original circuit topology. Decoupling wiring specifications from model\ninstantiation allows dynamic connectivity adjustments to\naccommodate different input modalities without full retraining. Algorithm 1 summarizes the steps for repurposing the\nNCPs wiring mechanism. Key features include group-wise\nmasking for neuron isolation, adaptive remapping of inputs\nand outputs for task-specific adaptation, and tunable sparsity\n_s_ to balance expressiveness and efficiency.\nIn our implementation, the sensory neuron gate ( _NN_ sensory)\nprojects the _q_, _k_, and _v_ representations (see Figure 1(b)).\nThis enables sensory neurons to maintain structured, contextaware representations rather than collapsing inputs into fully\n\n\n\nconnected layers. As a result, the network preserves locality\nand modularity, which improves information routing.\n\n\n_NN_ sensory = NCPCell( _G_ input = [ _Ns_ ] _, G_ output = [ _Ns_ ] _,_\n\n_D_ = [ _Ni, Nc, Nm_ ] _, s_ )\n(13)\nThe inter-to-motor pathways form a backbone network\n( _NN_ backbone) with branches that compute _ϕ_ and _ωτ_ (see\nFigure 1(c)). Instead of learning _ϕ_ and _ωτ_ independently,\nthis backbone allows the model to learn shared representations, enabling multiple benefits: (i) separate head layers\nenable the system to capture temporal and structural dependencies independently; (ii) accelerates convergence during\ntraining.\n\n\n_NN_ backbone = NCPCell( _G_ input = [ _Ni_ ] _, G_ output = [ _Nm_ ] _,_\n\n_D_ = [ _Ns_ ] _, s_ )\n(14)\nThe output heads are defined as:\n\n\n_ϕ_ = _σ_ ( _NN_ backbone( **u** )) (15)\n\n_ωτ_ = softplus( _NN_ backbone( **u** )) + _ε,_ _ε >_ 0 (16)\n\n\nHere, _ϕ_ serves as a _content–target gate_ head, where the\nsigmoid function _σ_ ( _·_ ) determines the target signal strength.\nIn contrast, _ωτ_ is a strictly positive _time–constant gate_ head\nthat controls the rate of convergence and the steady-state\namplitude. Conceptually, this parallels recurrent gating: _ϕ_\nregulates _what_ content to emphasize, while _ωτ_ governs _how_\n_quickly_ and _to what extent_ it is expressed.\n**Input Curation:** We experimented with different\nstrategies for constructing query–key inputs. Initially, we implemented full pairwise concatenation,\nwhere queries _Q ∈_ R _[B][×][H][×][T][q][×][D]_ are combined with\nall keys _K_ _∈_ R _[B][×][H][×][T][k][×][D]_ to form a joint tensor\n_U ∈_ R _[B][×][H][×][T][q][×][T][k][×]_ [2] _[D]_ . While this preserved complete\nfeature information and enabled expressive, learnable\nsimilarity functions, it was memory-intensive, making it impractical for longer sequences. To mitigate this, we applied\na sparse Top- _K_ optimization: for each query, we compute\npairwise scores _S_ = _Q · K_ _[⊤]_ _∈_ R _[B][×][H][×][T][q][×][T][k]_, select the\nTop- _K_ eff = min( _K, Tk_ ) keys, and construct concatenated\npairs _U_ topk _∈_ R _[B][×][H][×][T][q][×][K]_ [eff] _[×]_ [2] _[D]_ . This approach preserves\nthe most relevant interactions while substantially reducing\nmemory requirements in the concatenation and subsequent\nbackbone processing stages, allowing the method to scale\nlinearly with the sequence length in those components.\nHowever, the initial computation of _S_ remains quadratic\n(see Appendix C.3). Algorithm 2 outlines the steps required\nfor input curation.\n**Time Vector:** NAC builds on continuous-depth models\nas (Hasani et al., 2022) that adapt their temporal dynamics to the task. It constructs an internal, normalized\npseudo-time vector _t_ pseudo using a sigmoidal transformation,\n_t_ pseudo = _σ_ ( _ta · t_ + _tb_ ), where _ta_ and _tb_ are learnable affine\n\n\n\n4\n\n\n**Neuronal Attention Circuit (NAC) for Representation Learning**\n\n\n\nparameters and _σ_ is the sigmoid function. For time-varying\ndatasets (e.g., irregularly sampled series), each time point\n_t_ is derived from the sample’s timestamp, while for tasks\nwithout meaningful timing, _t_ is set to 1. The resulting _t_ pseudo\nlies in [0 _,_ 1] and provides a smooth, bounded representation\nof time for modulating the network’s dynamics.\n**Attention logits and weights:** Starting from Eqn. 3,\nconsider the trajectory of a query–key pair with initial\ncondition _a_ 0 = 0:\n\n\n\n_at_ = _[ϕ]_\n\n_ωτ_\n\n\n\n�1 _−_ _e_ _[−][ω][τ][ t]_ [�] _,_ (17)\n\n\n\nfollowed by the _softmax_ normalization to calculate attention weights. The resulting attention weights _αt_ [(] _[h]_ [)] are then\nused to integrate with the value vector _v_ [(] _[h]_ [)], producing headspecific attention outputs. Finally, these outputs are concatenated and linearly projected back into the model dimension.\nThis formulation ensures that each head learns distinct dynamic compatibilities governed by its own parameterization\nof _ϕ_ and _ωτ_, while the aggregation across heads preserves\nthe expressive capacity of the standard multi-head attention\nmechanism.\n\n\n**2.3. NAC as Universal Approximator**\n\n\nWe now establish the universal approximation capability of\nNAC by extending the classical Universal Approximation\nTheorem (UAT) (Nishijima, 2021) to the proposed mechanism. For brevity, we consider a network with a single\nNAC layer processing fixed-dimensional inputs, though the\nargument generalizes to sequences."}, {"chunk_id": "attention_is_all_you_need_raw_chunks_2k_0", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl", "metadata": {"source": "attention_is_all_you_need_raw.md", "chunk_id": "attention_is_all_you_need_raw_chunks_2k_0", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl"}, "text": "Provided proper attribution is provided, Google hereby grants permission to\nreproduce the tables and figures in this paper solely for use in journalistic or\nscholarly works.\n\n## **Attention Is All You Need**\n\n\n\n**Niki Parmar** _[∗]_\nGoogle Research\n```\nnikip@google.com\n\n```\n\n\n**Ashish Vaswani** _[∗]_\nGoogle Brain\n```\navaswani@google.com\n\n```\n\n**Llion Jones** _[∗]_\nGoogle Research\n```\n llion@google.com\n\n```\n\n\n**Noam Shazeer** _[∗]_\nGoogle Brain\n```\nnoam@google.com\n\n```\n\n\n**Jakob Uszkoreit** _[∗]_\nGoogle Research\n```\nusz@google.com\n\n```\n\n\n**Aidan N. Gomez** _[∗†]_\nUniversity of Toronto\n```\naidan@cs.toronto.edu\n\n```\n\n\n**Łukasz Kaiser** _[∗]_\nGoogle Brain\n```\nlukaszkaiser@google.com\n\n```\n\n\n**Illia Polosukhin** _[∗‡]_\n\n```\n             illia.polosukhin@gmail.com\n\n```\n\n**Abstract**\n\n\nThe dominant sequence transduction models are based on complex recurrent or\nconvolutional neural networks that include an encoder and a decoder. The best\nperforming models also connect the encoder and decoder through an attention\nmechanism. We propose a new simple network architecture, the Transformer,\nbased solely on attention mechanisms, dispensing with recurrence and convolutions\nentirely. Experiments on two machine translation tasks show these models to\nbe superior in quality while being more parallelizable and requiring significantly\nless time to train. Our model achieves 28.4 BLEU on the WMT 2014 Englishto-German translation task, improving over the existing best results, including\nensembles, by over 2 BLEU. On the WMT 2014 English-to-French translation task,\nour model establishes a new single-model state-of-the-art BLEU score of 41.8 after\ntraining for 3.5 days on eight GPUs, a small fraction of the training costs of the\nbest models from the literature. We show that the Transformer generalizes well to\nother tasks by applying it successfully to English constituency parsing both with\nlarge and limited training data.\n\n\n_∗_ Equal contribution. Listing order is random. Jakob proposed replacing RNNs with self-attention and started\nthe effort to evaluate this idea. Ashish, with Illia, designed and implemented the first Transformer models and\nhas been crucially involved in every aspect of this work. Noam proposed scaled dot-product attention, multi-head\nattention and the parameter-free position representation and became the other person involved in nearly every\ndetail. Niki designed, implemented, tuned and evaluated countless model variants in our original codebase and\ntensor2tensor. Llion also experimented with novel model variants, was responsible for our initial codebase, and\nefficient inference and visualizations. Lukasz and Aidan spent countless long days designing various parts of and\nimplementing tensor2tensor, replacing our earlier codebase, greatly improving results and massively accelerating\nour research.\n\n_†_ Work performed while at Google Brain.\n\n_‡_ Work performed while at Google Research.\n\n\n31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, USA.\n\n\n**1** **Introduction**\n\n\nRecurrent neural networks, long short-term memory [13] and gated recurrent [7] neural networks\nin particular, have been firmly established as state of the art approaches in sequence modeling and\ntransduction problems such as language modeling and machine translation [35, 2, 5]. Numerous\nefforts have since continued to push the boundaries of recurrent language models and encoder-decoder\narchitectures [38, 24, 15].\n\n\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates _ht_, as a function of the previous hidden state _ht−_ 1 and the input for position _t_ . This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples. Recent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\n\n\nAttention mechanisms have become an integral part of compelling sequence modeling and transduction models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19]. In all but a few cases [27], however, such attention mechanisms\nare used in conjunction with a recurrent network.\n\n\nIn this work we propose the Transformer, a model architecture eschewing recurrence and instead\nrelying entirely on an attention mechanism to draw global dependencies between input and output.\nThe Transformer allows for significantly more parallelization and can reach a new state of the art in\ntranslation quality after being trained for as little as twelve hours on eight P100 GPUs.\n\n\n**2** **Background**\n\n\nThe goal of reducing sequential computation also forms the foundation of the Extended Neural GPU\n\n[16], ByteNet [18] and ConvS2S [9], all of which use convolutional neural networks as basic building\nblock, computing hidden representations in parallel for all input and output positions. In these models,\nthe number of operations required to relate signals from two arbitrary input or output positions grows\nin the distance between positions, linearly for ConvS2S and logarithmically for ByteNet. This makes\nit more difficult to learn dependencies between distant positions [12]. In the Transformer this is\nreduced to a constant number of operations, albeit at the cost of reduced effective resolution due\nto averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as\ndescribed in section 3.2.\n\n\nSelf-attention, sometimes called intra-attention is an attention mechanism relating different positions\nof a single sequence in order to compute a representation of the sequence. Self-attention has been\nused successfully in a variety of tasks including reading comprehension, abstractive summarization,\ntextual entailment and learning task-independent sentence representations [4, 27, 28, 22].\n\n\nEnd-to-end memory networks are based on a recurrent attention mechanism instead of sequencealigned recurrence and have been shown to perform well on simple-language question answering and\nlanguage modeling tasks [34].\n\n\nTo the best of our knowledge, however, the Transformer is the first transduction model relying\nentirely on self-attention to compute representations of its input and output without using sequencealigned RNNs or convolution. In the following sections, we will describe the Transformer, motivate\nself-attention and discuss its advantages over models such as [17, 18] and [9].\n\n\n**3** **Model Architecture**\n\n\nMost competitive neural sequence transduction models have an encoder-decoder structure [5, 2, 35].\nHere, the encoder maps an input sequence of symbol representations ( _x_ 1 _, ..., xn_ ) to a sequence\nof continuous representations **z** = ( _z_ 1 _, ..., zn_ ). Given **z**, the decoder then generates an output\nsequence ( _y_ 1 _, ..., ym_ ) of symbols one element at a time. At each step the model is auto-regressive\n\n[10], consuming the previously generated symbols as additional input when generating the next.\n\n\n2\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-2-0.png)\n\nFigure 1: The Transformer - model architecture.\n\n\nThe Transformer follows this overall architecture using stacked self-attention and point-wise, fully\nconnected layers for both the encoder and decoder, shown in the left and right halves of Figure 1,\nrespectively.\n\n\n**3.1** **Encoder and Decoder Stacks**"}, {"chunk_id": "attention_functional_roles_raw_chunks_2k_0", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl", "metadata": {"source": "attention_functional_roles_raw.md", "chunk_id": "attention_functional_roles_raw_chunks_2k_0", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl"}, "text": "## - INVESTIGATING THE FUNCTIONAL ROLES OF ATTEN ### TION HEADS IN VISION LANGUAGE MODELS: EVI DENCE FOR REASONING MODULES\n\n**Yanbei Jiang** **[1]** _[∗]_ **Xueqi Ma** **[1]** _[∗]_ **Shu Liu** **[1]** **Sarah Monazam Erfani** **[1]**\n\n**Tongliang Liu** **[2]** **James Bailey** **[1]** **Jey Han Lau** **[1]** **Krista A. Ehinger** **[1]**\n\n1The University of Melbourne 2The University of Sydney\n_{_ yanbeij, xueqim, shu6 _}_ @student.unimelb.edu.au\n_{_ sarah.erfani, baileyj, jeyhan.lau, kris.ehinger _}_ @unimelb.edu.au\ntongliang.liu@sydney.edu.au\n\n\nABSTRACT\n\n\nDespite excelling on multimodal benchmarks, vision–language models (VLMs)\nlargely remain a black box. In this paper, we propose a novel interpretability framework to systematically analyze the internal mechanisms of VLMs, focusing on the functional roles of attention heads in multimodal reasoning. To\nthis end, we introduce CogVision, a dataset that decomposes complex multimodal questions into step-by-step subquestions designed to simulate human reasoning through a chain-of-thought paradigm, with each subquestion associated\nwith specific receptive or cognitive functions such as high-level visual reception and inference. Using a probing-based methodology, we identify attention\nheads that specialize in these functions and characterize them as functional heads.\nOur analysis across diverse VLM families reveals that these functional heads\nare universally sparse, vary in number and distribution across functions, and\nmediate interactions and hierarchical organization. Furthermore, intervention\nexperiments demonstrate their critical role in multimodal reasoning: removing\nfunctional heads leads to performance degradation, while emphasizing them enhances accuracy. These findings provide new insights into the cognitive organization of VLMs and suggest promising directions for designing models with more\nhuman-aligned perceptual and reasoning abilities. Code and data are available at\nhttps://github.com/YanbeiJiang/CogVision.\n\n\n1 INTRODUCTION\n\n\nLarge Vision-Language Models (VLMs) (Zhu et al., 2023; Liu et al., 2023; Lu et al., 2024a) have\ndemonstrated remarkable success across diverse multimodal tasks, ranging from image captioning\nto visual question answering. Although VLMs can solve mathematical reasoning problems with\nvisual context (as shown in Fig. 1), their internal mechanisms remain poorly understood.\n\n\nFor humans, solving such complex problems (illustrated in Fig. 1) typically requires the collaboration of vision and language, engaging multiple brain regions (Barsalou, 2014): the occipital lobe\nfor visual reception, capturing and processing the content of the images; the temporal lobe supports\nlong-term memory and the recall of relevant factual knowledge, such as chemical concentration formulas (Wheeler et al., 1997); and the parietal and prefrontal cortices are involved in higher-order\nreasoning (Hubbard et al., 2005), to produce the correct answer.\n\n\nRecent research in interpretability has begun probing the internal organization of large language\nmodels (LLMs), revealing specialized attention heads for specific functions (Wu et al.; Li et al.,\n2023a; Zheng et al.). In the case of VLMs, several studies (Kang et al., 2025; Bi et al., 2025) have\nidentified sparse attention heads with special functional roles in tasks such as grounding. However,\nstudying VLMs in complex, multi-step reasoning scenarios remains underexplored. A deeper under\n\n_∗_ Both authors contributed equally to this research.\n\n\n1\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-0.png)\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-1.png)\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-2.png)\n\n\n\nDecision making\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-3.png)\n\nHigh-level Vision Reception\n\n\n\nLanguage Knowledge Recall\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-5.png)\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-6.png)\n\n\n\nMath Reasoning\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-7.png)\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-4.png)\n\nOccipital lobe Temporal lobe Parietal lobe Frontal lobe\n\n\n\n\n\n\n\n\n\nBy dividing the number of Solution A has a higher\n\nparticles by the solvent concentration of A, Solution A.\n\n\n\n\n\n\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-8.png)\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-1-11.png)\n\nFigure 1: To answer a complex question, the human brain engages multiple regions, each performing\ndistinct cognitive functions. We investigate whether specific attention heads in large vision language\nmodels play analogous functional roles in generating responses.\n\n\nstanding of whether such specialized components exist, how they are organized, and what functional\nroles they play in multimodal reasoning is therefore critical.\n\n\nIn this paper, we propose a novel interpretability framework for systematically analyzing the functional roles of attention heads-parallel units in transformer models that compute token-to-token\nattention-an important component in VLMs, with a focus on their contributions to reception (perceptual processing) and cognition. To facilitate this, we introduce CogVision, a dataset that bridges the\ngap between model analysis and human cognitive processes. CogVision decomposes multimodal\nqueries into step-by-step subquestions, each aligned with specific cognitive functions (such as math\nreasoning, decision-masking), thus enabling a fine-grained evaluation of reasoning aligned with the\nchain-of-thought (CoT) paradigm. Leveraging CogVision, we develop a probing method to identify and characterize attention heads responsible for distinct cognitive operations across vision and\nlanguage within the transformer architecture.\n\n\nWe conduct extensive experiments on three major VLM families, including Intern (Zhu et al., 2025),\nQwen (Yang et al., 2025), and Gemma (Team et al., 2025) with different model scales. Our results\nreveal the existence of cognitive heads that consistently exhibit **universal**, **sparse**, and **intrinsic**\nproperties across architectures. Further analysis of the correlations among these functional heads\nreveals **cross-function interactions**, where a single head may support multiple functions or modalities, and uncovers a **hierarchical structure** in which lower-level functional heads modulate higherlevel ones, showing the complexity of neural networks (Barsalou, 2014; Ono et al., 2022).\n\n\nFurthermore, we validate the functional importance of these heads by showing that their removal\ndegrades performance on complex tasks and leads to specific error patterns, while their enhancement improves reasoning capabilities. Our findings provide compelling evidence that these attention\nheads play a critical role in multimodal reasoning. This insight not only deepens our understanding of the internal organization of VLMs but also suggests potential avenues for designing more\ninterpretable and cognitive-inspired multimodal AI systems.\n\n\n2 COGVISION\n\n\nIn this section, we present our dataset Cognitive Vision (CogVision) that contains cognitive process\nin multimodal reasoning. CogVision contains 1,409 main questions and 5,744 subquestions. Each\n\n\n2"}, {"chunk_id": "attention_functional_roles_raw_chunks_2k_2", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl", "metadata": {"source": "attention_functional_roles_raw.md", "chunk_id": "attention_functional_roles_raw_chunks_2k_2", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl"}, "text": "Let _Nt_ denote the number of tokens in the generated answer _a_ _[M]_ _i_ [. To isolate semantically informative]\ncontent relevant to reasoning, we select the top- _k_ most important tokens, determined by prompting\nQwen3-30B LLM (Yang et al., 2025), yielding an index set _Ik_ with _|Ik|_ = _k_ . For each index\n_j ∈Ik_, we extract the corresponding attention head activations _Xj_, and compute the averaged\nactivation feature for the _m_ -th head in layer _l_ as ¯ _x_ _[m]_ _l_ = _k_ [1] � _j ∈Ikxml_ [. This results in a full set of]\n\nhead-level features _X_ [¯] _i_ = _{x_ ¯ _[m]_ _l_ _[|][ l][ ∈]_ [1] _[, . . ., L, m][ ∈]_ [1] _[, . . ., M]_ _[}]_ [.]\n\n\n3.2 FUNCTION PROBING\n\n\nFor the dataset with _N_ subQAF triplets, we collect all activations to construct the probing dataset:\n\n\n_D_ probe = _{_ (¯ _x_ _[m]_ _l_ _[, c]_ [)] _[i][}][N]_ _i_ =1 _[, l][ ∈{]_ [1] _[, . . ., L][}][, m][ ∈{]_ [1] _[, . . ., M]_ _[}]_ (1)\n\n\nFor classification based on CogVision, the training set includes 1,124 main questions with 4,604\nsubQAF triplet, while the testing set has 285 main questions with 1,141 triplets. Our probe takes\nthe form _pθ_ ( _x_ _[m]_ _l_ [) = sigmoid (] _[⟨][θ, x][m]_ _l_ _[⟩]_ [)][. There is one probe per attention head per layer per function.]\nFor each target function, the probe is trained by treating the attention-head outputs that lead to\ncorrect answers for that function as the positive class, and those associated with correct answers\nfrom other functions as the negative class. To ensure data balance, we select an equal number of\nnegative samples to match the positive ones. Given prior findings suggesting that cognitive functions\nmay vary by layer depth (Zheng et al.), we incorporate layer-wise information by computing the\naverage activation ¯ _xl_ = _M_ 1 � _Mm_ =1 _[x]_ [¯] _l_ _[m]_ [for each layer. We then augment each head-level vector with]\n\n\n4\n\n\nits corresponding layer summary, resulting in enriched features _x_ _[m]_ _l_ _[′]_ = [¯ _x_ _[m]_ _l_ [; ¯] _[x][l]_ []][ for probing. The]\nimportance for each head are then calculated based on the accuracy of predicting target function. The\neffectiveness of top-k tokens and layer information, as well as the sensitivity analysis with respect\nto the parameter _k_ and the choice of LLM fused for top-k token extraction, and prompt format, can\nbe found in Appendix A.8.\n\n\n4 EXPERIMENTS\n\n\nWe conduct a series of experiments on three VLM families across various model scales, including\nIntern (Zhu et al., 2025) (InternVL3-8B and InternVL3-2B), Qwen (Yang et al., 2025) (Qwen2.5VL-7B and Qwen2.5-VL-3B), and Gemma (Team et al., 2025) (Gemma3-4B and Gemma3-2B).\nWe analyze the commonalities and differences of functional heads (Subsection 4.1), validate their\ncontributions (Subsection 4.2), and examine correlations, including cross-function interactions and\nhierarchical organization (Subsection 4.3). We also assess their causal impact on downstream reasoning tasks (Subsection 4.4). Results confirm the existence of sparse, function-specific heads and\nhighlight their critical contribution to structured cognitive processing within VLMs.\n\n\n4.1 PROPERTIES OF COGNITIVE HEADS\n\n\n**Sparsity, Universality, and Intrinsic Organization:** Fig 2 shows the heatmap of attention head\naccuracy across eight functions in Qwen2.5-VL-7B on the CogVision test set, revealing a sparse\ndistribution. In total, fewer than 7% of all heads achieve accuracies above 0.9 across the eight functions (about 2% for high-level visual reception and math reasoning, and less than 1% for the others),\nsuggesting that only a small subset of heads meaningfully contributes to different reasoning tasks.\nThese results demonstrate that VLMs rely on highly specialized, localized components for distinct\ncognitive abilities. Pearson correlations between head-activation heatmaps across the eight functions\n(Fig. 3) are generally low, confirming that different functions tend to depend on partially separable\nsubsets of heads. Moreover, this sparse functional organization is consistent across architectures\nand scales: heatmaps for five additional models (Appendix A.4) confirm its universality, and the\nrelatively high Pearson correlation coefficients between models further verify this consistency (in\nAppendix A.9). Within the same model family (e.g., Qwen2.5-VL-7B in Fig 2 vs. Qwen2.5-VL-3B\nin Fig 8), we observe similar distributions, suggesting that such specialization is intrinsic to VLMs.\n\n\n**Functional Personalization:** Beyond sparsity, attention heads exhibit a structured distribution\nacross model layers. Math-related heads are dispersed throughout the network, whereas inferencerelated heads appear more frequently in higher layers. This task-dependent localization suggests an\nemergent modular organization in which different layers support distinct cognitive operations. We\nalso observe notable variation in head counts across functions. For example, in the Qwen family,\nmath reasoning and high-level visual reception heads are more prevalent than others, reflecting differences in representational and computational complexity. Smaller models contain fewer functional\nheads compared to their larger counterparts.\n\n\n4.2 FUNCTIONAL CONTRIBUTIONS OF COGNITIVE HEADS\n\n\nAfter identifying the cognitive heads associated with each function, we examine their functional\nroles by evaluating the model’s behavior on the CogVision test set under targeted interventions. We\nperform head ablation by scaling the output of a specific attention head with a small factor _ϵ_ (e.g.,\n0.001), effectively suppressing its contribution:\n\n\n\n�\n\n\n\n_x_ [mask] _i_ = Softmax\n\n\n\n_Wq_ _[i][W][ iT]_ _k_\n� ~~�~~ _dk/n_\n\n\n\n\n_· ϵWv_ _[i]_ (2)\n\n\n\nSpecifically, we compare model performance when masking identified cognitive heads versus masking an equal number of randomly-selected heads. To quantify the impact, we employ both an LLMbased judge and an integrated accuracy metric. For LLM-based judge, we use LLM (Qwen3-30B\nLLM (Yang et al., 2025)) to judge the correctness of the output. For the integrated accuracy metric,\nan output is considered unaffected if its BLEU score (Papineni et al., 2002) exceeds 0.8, or if either\n\n\n5\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_functional_roles.pdf-5-0.png)\n\nFigure 2: The existence of cognitive heads in Qwen2.5-VL-7B responsible for eight distinct functions in complex reasoning tasks. The x-axis represents the head index, while the y-axis indicates\nthe layer index. The values denote head importance scores, capped at a cutoff of 0.60.\n\n\nFigure 3: Pearson Correlation between different functions across two models.\n\n\nthe ROUGE score (Chin-Yew, 2004) or the semantic similarity score surpasses 0.6. This provides a\ncomprehensive evaluation of performance degradation."}, {"chunk_id": "attention_is_all_you_need_raw_chunks_2k_1", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl", "metadata": {"source": "attention_is_all_you_need_raw.md", "chunk_id": "attention_is_all_you_need_raw_chunks_2k_1", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl"}, "text": "[10], consuming the previously generated symbols as additional input when generating the next.\n\n\n2\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-2-0.png)\n\nFigure 1: The Transformer - model architecture.\n\n\nThe Transformer follows this overall architecture using stacked self-attention and point-wise, fully\nconnected layers for both the encoder and decoder, shown in the left and right halves of Figure 1,\nrespectively.\n\n\n**3.1** **Encoder and Decoder Stacks**\n\n\n**Encoder:** The encoder is composed of a stack of _N_ = 6 identical layers. Each layer has two\nsub-layers. The first is a multi-head self-attention mechanism, and the second is a simple, positionwise fully connected feed-forward network. We employ a residual connection [11] around each of\nthe two sub-layers, followed by layer normalization [1]. That is, the output of each sub-layer is\nLayerNorm( _x_ + Sublayer( _x_ )), where Sublayer( _x_ ) is the function implemented by the sub-layer\nitself. To facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension _d_ model = 512.\n\n\n**Decoder:** The decoder is also composed of a stack of _N_ = 6 identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack. Similar to the encoder, we employ residual connections\naround each of the sub-layers, followed by layer normalization. We also modify the self-attention\nsub-layer in the decoder stack to prevent positions from attending to subsequent positions. This\nmasking, combined with fact that the output embeddings are offset by one position, ensures that the\npredictions for position _i_ can depend only on the known outputs at positions less than _i_ .\n\n\n**3.2** **Attention**\n\n\nAn attention function can be described as mapping a query and a set of key-value pairs to an output,\nwhere the query, keys, values, and output are all vectors. The output is computed as a weighted sum\n\n\n3\n\n\nScaled Dot-Product Attention Multi-Head Attention\n\n\nFigure 2: (left) Scaled Dot-Product Attention. (right) Multi-Head Attention consists of several\nattention layers running in parallel.\n\n\nof the values, where the weight assigned to each value is computed by a compatibility function of the\nquery with the corresponding key.\n\n\n**3.2.1** **Scaled Dot-Product Attention**\n\n\nWe call our particular attention \"Scaled Dot-Product Attention\" (Figure 2). The input consists of\nqueries and keys of dimension _dk_, and values of dimension _dv_ . We compute the dot products of the\nquery with all keys, divide each by _[√]_ _dk_, and apply a softmax function to obtain the weights on the\nvalues.\n\n\nIn practice, we compute the attention function on a set of queries simultaneously, packed together\ninto a matrix _Q_ . The keys and values are also packed together into matrices _K_ and _V_ . We compute\nthe matrix of outputs as:\n\n\nAttention( _Q, K, V_ ) = softmax( _[Q][K]_ _[T]_ ) _V_ (1)\n\n~~_√_~~ _dk_\n\n\nThe two most commonly used attention functions are additive attention [2], and dot-product (multiplicative) attention. Dot-product attention is identical to our algorithm, except for the scaling factor\nof ~~_√_~~ 1 _dk_ . Additive attention computes the compatibility function using a feed-forward network with\na single hidden layer. While the two are similar in theoretical complexity, dot-product attention is\nmuch faster and more space-efficient in practice, since it can be implemented using highly optimized\nmatrix multiplication code.\n\n\nWhile for small values of _dk_ the two mechanisms perform similarly, additive attention outperforms\ndot product attention without scaling for larger values of _dk_ [3]. We suspect that for large values of\n_dk_, the dot products grow large in magnitude, pushing the softmax function into regions where it has\nextremely small gradients [4] . To counteract this effect, we scale the dot products by ~~_√_~~ 1 _dk_ .\n\n\n**3.2.2** **Multi-Head Attention**\n\n\nInstead of performing a single attention function with _d_ model-dimensional keys, values and queries,\nwe found it beneficial to linearly project the queries, keys and values _h_ times with different, learned\nlinear projections to _dk_, _dk_ and _dv_ dimensions, respectively. On each of these projected versions of\nqueries, keys and values we then perform the attention function in parallel, yielding _dv_ -dimensional\n\n\n4To illustrate why the dot products get large, assume that the components of _q_ and _k_ are independent random\nvariables with mean 0 and variance 1. Then their dot product, _q · k_ = [�] _[d]_ _i_ =1 _[k]_ _[q][i][k][i]_ [, has mean][ 0][ and variance] _[ d][k]_ [.]\n\n\n4\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-3-0.png)\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-3-1.png)\noutput values. These are concatenated and once again projected, resulting in the final values, as\ndepicted in Figure 2.\n\n\nMulti-head attention allows the model to jointly attend to information from different representation\nsubspaces at different positions. With a single attention head, averaging inhibits this.\n\n\nMultiHead( _Q, K, V_ ) = Concat(head1 _, ...,_ headh) _W_ _[O]_\n\nwhere headi = Attention( _QWi_ _[Q][, KW][ K]_ _i_ _[, V W][ V]_ _i_ [)]\n\n\nWhere the projections are parameter matrices _Wi_ _[Q]_ _∈_ R _[d]_ [model] _[×][d][k]_, _Wi_ _[K]_ _∈_ R _[d]_ [model] _[×][d][k]_, _Wi_ _[V]_ _∈_ R _[d]_ [model] _[×][d][v]_\nand _W_ _[O]_ _∈_ R _[hd][v][×][d]_ [model] .\n\n\nIn this work we employ _h_ = 8 parallel attention layers, or heads. For each of these we use\n_dk_ = _dv_ = _d_ model _/h_ = 64. Due to the reduced dimension of each head, the total computational cost\nis similar to that of single-head attention with full dimensionality.\n\n\n**3.2.3** **Applications of Attention in our Model**\n\n\nThe Transformer uses multi-head attention in three different ways:\n\n\n    - In \"encoder-decoder attention\" layers, the queries come from the previous decoder layer,\nand the memory keys and values come from the output of the encoder. This allows every\nposition in the decoder to attend over all positions in the input sequence. This mimics the\ntypical encoder-decoder attention mechanisms in sequence-to-sequence models such as\n\n[38, 2, 9].\n\n\n    - The encoder contains self-attention layers. In a self-attention layer all of the keys, values\nand queries come from the same place, in this case, the output of the previous layer in the\nencoder. Each position in the encoder can attend to all positions in the previous layer of the\nencoder.\n\n\n    - Similarly, self-attention layers in the decoder allow each position in the decoder to attend to\nall positions in the decoder up to and including that position. We need to prevent leftward\ninformation flow in the decoder to preserve the auto-regressive property. We implement this\ninside of scaled dot-product attention by masking out (setting to _−∞_ ) all values in the input\nof the softmax which correspond to illegal connections. See Figure 2."}, {"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_4", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl", "metadata": {"source": "neuronal_attention_circuits_raw.md", "chunk_id": "neuronal_attention_circuits_raw_chunks_2k_4", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}, "text": "**2.3. NAC as Universal Approximator**\n\n\nWe now establish the universal approximation capability of\nNAC by extending the classical Universal Approximation\nTheorem (UAT) (Nishijima, 2021) to the proposed mechanism. For brevity, we consider a network with a single\nNAC layer processing fixed-dimensional inputs, though the\nargument generalizes to sequences.\n\n\n**Theorem 2** (Universal Approximation by NAC) **.** _Let K ⊂_\nR _[n]_ _be a compact set and f_ : _K →_ R _[m]_ _be a continuous_\n_function. For any ϵ >_ 0 _, there exists a neural network_\n_consisting of a single NAC layer, with sufficiently large_\n_model dimension dmodel, number of heads H, sparsity s,_\n_and nonlinear activations, such that the network’s output_\n_g_ : R _[n]_ _→_ R _[m]_ _satisfies_\n\n\nsup _∥f_ ( _x_ ) _−_ _g_ ( _x_ ) _∥_ _< ϵ._ (20)\n_x∈K_\n\n\n_The proof is provided in Appendix B.3._\n\n\n**3. Evaluation**\n\n\nWe evaluate the proposed architecture against a range of\nbaselines, including (DT & CT) RNN, (DT & CT) attention,\nand multiple NAC ablation configurations. Experiments\nare conducted across diverse domains, including irregular\ntime-series modeling, lane keeping of autonomous vehicles,\nand Industry 4.0 prognostics. All results are obtained using 5-fold cross-validation, where models are trained using\nBPTT (see Appendix C.2) on each fold and evaluated across\nall folds. We report the mean ( _µ_ ) and standard deviation ( _σ_ )\nto capture variability and quantify uncertainty in the predictions. Table 1 provides results for all experiments, and the\ndetails of the baselines, ablation, environment utilized, the\ndata curation and preprocessing, and neural network architectures for all experiments are provided in the Appendix\nD.3.\n\n\n**3.1. Irregular Time-series**\n\n\nWe evaluate the proposed architecture on two irregular timeseries datasets: (i) Event-based MNIST; and (ii) Person\nActivity Recognition (PAR).\n\n\n\nFor finite _t_, the exponential factor (1 _−_ _e_ _[−][ω][τ][ t]_ ) regulates the\nbuildup of attention, giving _ωτ_ a temporal gating role. Normalizing across all keys via _softmax_ yields attention weights\n_αt_ = softmax( _at_ ), defining a valid probability distribution\nwhere _ϕ_ amplifies or suppresses content alignments, and _ωτ_\nshapes both the speed and saturation of these preferences.\nAs _t →∞_, the trajectory converges to the steady state\n\n\n_a_ _[∗]_ _t_ [=] _[ϕ]_ _≈_ _[q][⊤][k]_ _,_ (18)\n\n_ωτ_ ~~_√_~~ _dk_\n\n\nwhich is analogous to scaled-dot attention under specific\nparameterization when the backbone _NN_ backbone is configured as a linear projection such that _ϕ_ ( **u** ) = _q_ _[⊤]_ _k_ and\n_ωτ_ ( _u_ ) = _[√]_ _dk_ (e.g., by setting NCP weights to emulate\nbilinear forms and disabling nonlinearities). In general, the\nnonlinear backbone allows for more expressive similarities,\nwith the approximation holding when trained to mimic dot\nproducts.\n**Attention output:** Finally, the attention output is computed\nby integrating the attention weights with the value matrix:\n\n\nNAC( _q, k, v_ ) = _αtvtdt_ (19)\n� _T_\n\n\nIn practice, the integration is approximated using a Riemannstyle approach, where the weighted elements are computed\nby multiplying each _vt_ with its corresponding _αt_ . These are\nthen summed and multiplied by a fixed pseudo-time step\n_δt_, chosen as a scalar (typically between 0.5–1.0) hyperparameter during layer initialization. This yields a continuous\nanalogue of standard weighted sums, giving finer resolution\nof the attention trajectory without altering the underlying\nvalues. Sensitivity to attention output w.r.t _δt_ is visualized\nin Appendix D.2.\n\n\n2.2.1. EXTENSION TO MULTI-HEAD\n\n\nTo scale this mechanism to multi-head attention, we project\nthe input sequence into _H_ independent subspaces (heads)\nof dimension _d_ model _/H_, yielding query, key, and value tensors ( _q_ [(] _[h]_ [)] _, k_ [(] _[h]_ [)] _, v_ [(] _[h]_ [)] ) for _h ∈{_ 1 _, . . ., H}_ . For each head,\npairwise logits are computed according to Eqns. 2,3 or 18,\n\n\n\n5\n\n\n**Neuronal Attention Circuit (NAC) for Representation Learning**\n\n\n_Figure 2._ Illustration of the architecture of **(a)** Neuronal Attention Circuit mechanism ; **(b)** Multi-Head Extension\n\n\n\n![](E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/neuronal_attention_circuits.pdf-5-0.png)\n\n**Event-based MNIST:** Event-based MNIST is the trans\nformation of the widely recognized MNIST dataset with\nirregular sampling added originally proposed in (Lechner\n& Hasani, 2022). The transformation was done in two\nsteps: (i) flattening each 28×28 image into a time series\nof length 784, and (ii) encoding the binary time series into\nan event-based format by collapsing consecutive identical\nvalues (e.g., 1,1,1,1 → (1, t=4)). This representation requires models to handle temporal dependencies effectively.\nNAC-PW achieved first place with an accuracy of 96.64%,\nfollowed by NAC-Exact/05s/8k at 96.12%. GRU-ODE and\nContiFormer ranked third with 96.04%.\n\n**Person Activity Recognition (PAR):** We employed the\nLocalized Person Activity dataset from UC Irvine (Vidulin\net al., 2010). The dataset contains data from five participants,\neach equipped with inertial measurement sensors sampled\nevery 211 ms. The goal of this experiment is to predict a\nperson’s activity from a set of predefined actions, making it\na classification task. All models performed well on this task,\nwith NAC-PW achieving 89.15% accuracy and taking first\nplace. NAC-Exact/05s/8k and GRU-ODE ranked second\nwith 89.01% accuracy, while NAC-02s ranked third with\n88.84% mean accuracy.\n\n\n**3.2. Lane-Keeping of Autonomous Vehicles**\n\n\nLane keeping in autonomous vehicles (AVs) is a fundamental problem in robotics and AI. Early works (Tiang et al.,\n2018; Park et al., 2021) primarily emphasized accuracy,\noften relying on large models. More recent research (Lechner et al., 2020; Razzaq & Hongwei, 2023) has shifted toward designing compact architectures suitable for resourceconstrained devices. The goal of this experiment is to create\na long causal structure between the road’s horizon and the"}], "retrieved_by_subquery": [{"subquery": "anaphora resolution attention mechanism", "hits": [{"chunk_id": "attention_is_all_you_need_raw_chunks_2k_2", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl"}, {"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_0", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}, {"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_3", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}]}, {"subquery": "attention-based anaphora resolution models", "hits": [{"chunk_id": "attention_is_all_you_need_raw_chunks_2k_0", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl"}, {"chunk_id": "attention_is_all_you_need_raw_chunks_2k_2", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl"}, {"chunk_id": "attention_functional_roles_raw_chunks_2k_0", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl"}]}, {"subquery": "using attention for coreference resolution", "hits": [{"chunk_id": "attention_functional_roles_raw_chunks_2k_2", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl"}, {"chunk_id": "attention_is_all_you_need_raw_chunks_2k_1", "source_file": "attention_is_all_you_need_raw_chunks_2k.jsonl"}, {"chunk_id": "attention_functional_roles_raw_chunks_2k_0", "source_file": "attention_functional_roles_raw_chunks_2k.jsonl"}]}, {"subquery": "anaphora resolution with neural attention", "hits": [{"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_3", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}, {"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_0", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}, {"chunk_id": "neuronal_attention_circuits_raw_chunks_2k_4", "source_file": "neuronal_attention_circuits_raw_chunks_2k.jsonl"}]}], "error": null, "latency_ms": 3872}, "graph": {"query": "how is anaphora resolution done using attention mechanism?", "grounded_entities": [{"labels": ["Concept"], "name": "anaphora resolution", "score": 4.364219665527344}, {"labels": ["Concept"], "name": "Attention mechanism", "score": 1.0319732427597046}, {"labels": ["Concept"], "name": "attention heads", "score": 1.0319732427597046}, {"labels": ["Concept"], "name": "attention patterns", "score": 1.0319732427597046}, {"labels": ["Concept"], "name": "Attention weights", "score": 1.0319732427597046}], "generated_cypher": "MATCH (c1:Concept {id:'anaphora resolution'})<-[:MENTIONS]-(d:Document)-[:MENTIONS]->(c2:Concept {id:'Attention mechanism'})\nWHERE d.source_type = 'chunk'\nRETURN d.source_id, d.chunk_file, d.chunk_id, d.chunk_index, d.text\nLIMIT 10", "raw_context_rows": [], "fallback_used": true, "retrieved_subgraph": {"nodes": [{"id": "Attention mechanism", "properties": {"id": "Attention mechanism"}, "labels": ["Concept"]}, {"id": "attention heads", "properties": {"id": "attention heads"}, "labels": ["Concept"]}, {"id": "attention patterns", "properties": {"id": "attention patterns"}, "labels": ["Concept"]}, {"id": "anaphora resolution", "properties": {"id": "anaphora resolution"}, "labels": ["Concept"]}, {"id": "Attention weights", "properties": {"id": "Attention weights"}, "labels": ["Concept"]}, {"id": "c35df05545627694d3b4bbf52619a5da", "properties": {"chunk_index": "0", "chunk_file": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl", "source_type": "chunk", "id": "c35df05545627694d3b4bbf52619a5da", "text": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_0", "source_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_0", "chunk_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_0"}, "labels": ["Document"]}, {"id": "888d0bd62e26d30498c9f50b218a6001", "properties": {"chunk_index": "2", "chunk_file": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl", "source_type": "chunk", "id": "888d0bd62e26d30498c9f50b218a6001", "text": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_2", "source_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_2", "chunk_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_2"}, "labels": ["Document"]}, {"id": "36f927c2ec5951b1af0611a9728d214b", "properties": {"derived_from_chunk_file": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl", "markdown_source": "attention_is_all_you_need_raw_with_image_ids_with_captions.md", "source_type": "markdown", "id": "36f927c2ec5951b1af0611a9728d214b", "text": "attention_is_all_you_need_raw_with_image_ids_with_captions.md::images", "source_id": "attention_is_all_you_need_raw_with_image_ids_with_captions.md::images"}, "labels": ["Document"]}, {"id": "img_attention_is_all_you_need_12_0", "properties": {"id": "img_attention_is_all_you_need_12_0", "source_path": "E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-12-0.png"}, "labels": ["Image"]}, {"id": "Transformer", "properties": {"id": "Transformer"}, "labels": ["Model"]}, {"id": "Encoder-decoder architectures", "properties": {"id": "Encoder-decoder architectures"}, "labels": ["Model"]}, {"id": "Active memory", "properties": {"id": "Active memory"}, "labels": ["Concept"]}, {"id": "93ec065e0391e99e3dd12c28af8c5ff9", "properties": {"chunk_index": "1", "chunk_file": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl", "source_type": "chunk", "id": "93ec065e0391e99e3dd12c28af8c5ff9", "text": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_1", "source_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k.jsonl::attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_1", "chunk_id": "attention_is_all_you_need_raw_with_image_ids_with_captions_chunks_5k_1"}, "labels": ["Document"]}, {"id": "img_attention_is_all_you_need_13_0", "properties": {"id": "img_attention_is_all_you_need_13_0", "source_path": "E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-13-0.png"}, "labels": ["Image"]}, {"id": "img_attention_is_all_you_need_14_0", "properties": {"id": "img_attention_is_all_you_need_14_0", "source_path": "E:/Python Stuff/MAS-for-multimodal-knowledge-graph/markdown_outputs/images/attention_is_all_you_need.pdf-14-0.png"}, "labels": ["Image"]}], "edges": [{"source": "c35df05545627694d3b4bbf52619a5da", "type": "MENTIONS", "properties": {}, "target": "Attention mechanism"}, {"source": "888d0bd62e26d30498c9f50b218a6001", "type": "MENTIONS", "properties": {}, "target": "Attention mechanism"}, {"source": "36f927c2ec5951b1af0611a9728d214b", "type": "MENTIONS", "properties": {}, "target": "Attention mechanism"}, {"source": "img_attention_is_all_you_need_12_0", "type": "DEPICTS", "properties": {}, "target": "Attention mechanism"}, {"source": "Transformer", "type": "BUILDS_ON", "properties": {}, "target": "Attention mechanism"}, {"source": "Encoder-decoder architectures", "type": "BUILDS_ON", "properties": {}, "target": "Attention mechanism"}, {"source": "Active memory", "type": "COMPARED_WITH", "properties": {}, "target": "Attention mechanism"}, {"source": "Transformer", "type": "EXTENDS", "properties": {}, "target": "Attention mechanism"}, {"source": "93ec065e0391e99e3dd12c28af8c5ff9", "type": "MENTIONS", "properties": {}, "target": "attention heads"}, {"source": "36f927c2ec5951b1af0611a9728d214b", "type": "MENTIONS", "properties": {}, "target": "attention heads"}, {"source": "img_attention_is_all_you_need_13_0", "type": "DEPICTS", "properties": {}, "target": "attention heads"}, {"source": "36f927c2ec5951b1af0611a9728d214b", "type": "MENTIONS", "properties": {}, "target": "attention patterns"}, {"source": "img_attention_is_all_you_need_13_0", "type": "DEPICTS", "properties": {}, "target": "attention patterns"}, {"source": "36f927c2ec5951b1af0611a9728d214b", "type": "MENTIONS", "properties": {}, "target": "anaphora resolution"}, {"source": "img_attention_is_all_you_need_13_0", "type": "DEPICTS", "properties": {}, "target": "anaphora resolution"}, {"source": "36f927c2ec5951b1af0611a9728d214b", "type": "MENTIONS", "properties": {}, "target": "Attention weights"}, {"source": "img_attention_is_all_you_need_14_0", "type": "DEPICTS", "properties": {}, "target": "Attention weights"}]}, "error": null, "latency_ms": 10376}}}